// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: im.cm.proto

#ifndef PROTOBUF_INCLUDED_im_2ecm_2eproto
#define PROTOBUF_INCLUDED_im_2ecm_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "im.pub.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_im_2ecm_2eproto 

namespace protobuf_im_2ecm_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
}  // namespace protobuf_im_2ecm_2eproto
namespace im {
class CMKickoutNotification;
class CMKickoutNotificationDefaultTypeInternal;
extern CMKickoutNotificationDefaultTypeInternal _CMKickoutNotification_default_instance_;
class CMLogin;
class CMLoginDefaultTypeInternal;
extern CMLoginDefaultTypeInternal _CMLogin_default_instance_;
class CMLoginAck;
class CMLoginAckDefaultTypeInternal;
extern CMLoginAckDefaultTypeInternal _CMLoginAck_default_instance_;
class CMLoginNotify;
class CMLoginNotifyDefaultTypeInternal;
extern CMLoginNotifyDefaultTypeInternal _CMLoginNotify_default_instance_;
class CMLoginNotifyAck;
class CMLoginNotifyAckDefaultTypeInternal;
extern CMLoginNotifyAckDefaultTypeInternal _CMLoginNotifyAck_default_instance_;
class CMLoginTrans;
class CMLoginTransDefaultTypeInternal;
extern CMLoginTransDefaultTypeInternal _CMLoginTrans_default_instance_;
class CMLogout;
class CMLogoutDefaultTypeInternal;
extern CMLogoutDefaultTypeInternal _CMLogout_default_instance_;
class CMLogoutAck;
class CMLogoutAckDefaultTypeInternal;
extern CMLogoutAckDefaultTypeInternal _CMLogoutAck_default_instance_;
class CMPHPLoginNotify;
class CMPHPLoginNotifyDefaultTypeInternal;
extern CMPHPLoginNotifyDefaultTypeInternal _CMPHPLoginNotify_default_instance_;
class CMPHPLoginNotifyACK;
class CMPHPLoginNotifyACKDefaultTypeInternal;
extern CMPHPLoginNotifyACKDefaultTypeInternal _CMPHPLoginNotifyACK_default_instance_;
class LoginCMNotify;
class LoginCMNotifyDefaultTypeInternal;
extern LoginCMNotifyDefaultTypeInternal _LoginCMNotify_default_instance_;
class LoginCMNotifyAck;
class LoginCMNotifyAckDefaultTypeInternal;
extern LoginCMNotifyAckDefaultTypeInternal _LoginCMNotifyAck_default_instance_;
}  // namespace im
namespace google {
namespace protobuf {
template<> ::im::CMKickoutNotification* Arena::CreateMaybeMessage<::im::CMKickoutNotification>(Arena*);
template<> ::im::CMLogin* Arena::CreateMaybeMessage<::im::CMLogin>(Arena*);
template<> ::im::CMLoginAck* Arena::CreateMaybeMessage<::im::CMLoginAck>(Arena*);
template<> ::im::CMLoginNotify* Arena::CreateMaybeMessage<::im::CMLoginNotify>(Arena*);
template<> ::im::CMLoginNotifyAck* Arena::CreateMaybeMessage<::im::CMLoginNotifyAck>(Arena*);
template<> ::im::CMLoginTrans* Arena::CreateMaybeMessage<::im::CMLoginTrans>(Arena*);
template<> ::im::CMLogout* Arena::CreateMaybeMessage<::im::CMLogout>(Arena*);
template<> ::im::CMLogoutAck* Arena::CreateMaybeMessage<::im::CMLogoutAck>(Arena*);
template<> ::im::CMPHPLoginNotify* Arena::CreateMaybeMessage<::im::CMPHPLoginNotify>(Arena*);
template<> ::im::CMPHPLoginNotifyACK* Arena::CreateMaybeMessage<::im::CMPHPLoginNotifyACK>(Arena*);
template<> ::im::LoginCMNotify* Arena::CreateMaybeMessage<::im::LoginCMNotify>(Arena*);
template<> ::im::LoginCMNotifyAck* Arena::CreateMaybeMessage<::im::LoginCMNotifyAck>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace im {

// ===================================================================

class CMLogin : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:im.CMLogin) */ {
 public:
  CMLogin();
  virtual ~CMLogin();

  CMLogin(const CMLogin& from);

  inline CMLogin& operator=(const CMLogin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMLogin(CMLogin&& from) noexcept
    : CMLogin() {
    *this = ::std::move(from);
  }

  inline CMLogin& operator=(CMLogin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const CMLogin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMLogin* internal_default_instance() {
    return reinterpret_cast<const CMLogin*>(
               &_CMLogin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CMLogin* other);
  friend void swap(CMLogin& a, CMLogin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMLogin* New() const final {
    return CreateMaybeMessage<CMLogin>(NULL);
  }

  CMLogin* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMLogin>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const CMLogin& from);
  void MergeFrom(const CMLogin& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CMLogin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sUserId = 1;
  void clear_suserid();
  static const int kSUserIdFieldNumber = 1;
  const ::std::string& suserid() const;
  void set_suserid(const ::std::string& value);
  #if LANG_CXX11
  void set_suserid(::std::string&& value);
  #endif
  void set_suserid(const char* value);
  void set_suserid(const char* value, size_t size);
  ::std::string* mutable_suserid();
  ::std::string* release_suserid();
  void set_allocated_suserid(::std::string* suserid);

  // string sLoginToken = 2;
  void clear_slogintoken();
  static const int kSLoginTokenFieldNumber = 2;
  const ::std::string& slogintoken() const;
  void set_slogintoken(const ::std::string& value);
  #if LANG_CXX11
  void set_slogintoken(::std::string&& value);
  #endif
  void set_slogintoken(const char* value);
  void set_slogintoken(const char* value, size_t size);
  ::std::string* mutable_slogintoken();
  ::std::string* release_slogintoken();
  void set_allocated_slogintoken(::std::string* slogintoken);

  // string sDeviceToken = 3;
  void clear_sdevicetoken();
  static const int kSDeviceTokenFieldNumber = 3;
  const ::std::string& sdevicetoken() const;
  void set_sdevicetoken(const ::std::string& value);
  #if LANG_CXX11
  void set_sdevicetoken(::std::string&& value);
  #endif
  void set_sdevicetoken(const char* value);
  void set_sdevicetoken(const char* value, size_t size);
  ::std::string* mutable_sdevicetoken();
  ::std::string* release_sdevicetoken();
  void set_allocated_sdevicetoken(::std::string* sdevicetoken);

  // uint64 nLoginTime = 4;
  void clear_nlogintime();
  static const int kNLoginTimeFieldNumber = 4;
  ::google::protobuf::uint64 nlogintime() const;
  void set_nlogintime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:im.CMLogin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr suserid_;
  ::google::protobuf::internal::ArenaStringPtr slogintoken_;
  ::google::protobuf::internal::ArenaStringPtr sdevicetoken_;
  ::google::protobuf::uint64 nlogintime_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_im_2ecm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMLoginAck : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:im.CMLoginAck) */ {
 public:
  CMLoginAck();
  virtual ~CMLoginAck();

  CMLoginAck(const CMLoginAck& from);

  inline CMLoginAck& operator=(const CMLoginAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMLoginAck(CMLoginAck&& from) noexcept
    : CMLoginAck() {
    *this = ::std::move(from);
  }

  inline CMLoginAck& operator=(CMLoginAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const CMLoginAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMLoginAck* internal_default_instance() {
    return reinterpret_cast<const CMLoginAck*>(
               &_CMLoginAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(CMLoginAck* other);
  friend void swap(CMLoginAck& a, CMLoginAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMLoginAck* New() const final {
    return CreateMaybeMessage<CMLoginAck>(NULL);
  }

  CMLoginAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMLoginAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const CMLoginAck& from);
  void MergeFrom(const CMLoginAck& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CMLoginAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sUserId = 1;
  void clear_suserid();
  static const int kSUserIdFieldNumber = 1;
  const ::std::string& suserid() const;
  void set_suserid(const ::std::string& value);
  #if LANG_CXX11
  void set_suserid(::std::string&& value);
  #endif
  void set_suserid(const char* value);
  void set_suserid(const char* value, size_t size);
  ::std::string* mutable_suserid();
  ::std::string* release_suserid();
  void set_allocated_suserid(::std::string* suserid);

  // uint64 nLastLoginTime = 3;
  void clear_nlastlogintime();
  static const int kNLastLoginTimeFieldNumber = 3;
  ::google::protobuf::uint64 nlastlogintime() const;
  void set_nlastlogintime(::google::protobuf::uint64 value);

  // .im.ErrCode nErr = 2;
  void clear_nerr();
  static const int kNErrFieldNumber = 2;
  ::im::ErrCode nerr() const;
  void set_nerr(::im::ErrCode value);

  // @@protoc_insertion_point(class_scope:im.CMLoginAck)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr suserid_;
  ::google::protobuf::uint64 nlastlogintime_;
  int nerr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_im_2ecm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMLogout : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:im.CMLogout) */ {
 public:
  CMLogout();
  virtual ~CMLogout();

  CMLogout(const CMLogout& from);

  inline CMLogout& operator=(const CMLogout& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMLogout(CMLogout&& from) noexcept
    : CMLogout() {
    *this = ::std::move(from);
  }

  inline CMLogout& operator=(CMLogout&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const CMLogout& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMLogout* internal_default_instance() {
    return reinterpret_cast<const CMLogout*>(
               &_CMLogout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(CMLogout* other);
  friend void swap(CMLogout& a, CMLogout& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMLogout* New() const final {
    return CreateMaybeMessage<CMLogout>(NULL);
  }

  CMLogout* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMLogout>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const CMLogout& from);
  void MergeFrom(const CMLogout& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CMLogout* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sUserId = 1;
  void clear_suserid();
  static const int kSUserIdFieldNumber = 1;
  const ::std::string& suserid() const;
  void set_suserid(const ::std::string& value);
  #if LANG_CXX11
  void set_suserid(::std::string&& value);
  #endif
  void set_suserid(const char* value);
  void set_suserid(const char* value, size_t size);
  ::std::string* mutable_suserid();
  ::std::string* release_suserid();
  void set_allocated_suserid(::std::string* suserid);

  // uint32 nDeviceType = 2;
  void clear_ndevicetype();
  static const int kNDeviceTypeFieldNumber = 2;
  ::google::protobuf::uint32 ndevicetype() const;
  void set_ndevicetype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:im.CMLogout)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr suserid_;
  ::google::protobuf::uint32 ndevicetype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_im_2ecm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMLogoutAck : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:im.CMLogoutAck) */ {
 public:
  CMLogoutAck();
  virtual ~CMLogoutAck();

  CMLogoutAck(const CMLogoutAck& from);

  inline CMLogoutAck& operator=(const CMLogoutAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMLogoutAck(CMLogoutAck&& from) noexcept
    : CMLogoutAck() {
    *this = ::std::move(from);
  }

  inline CMLogoutAck& operator=(CMLogoutAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const CMLogoutAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMLogoutAck* internal_default_instance() {
    return reinterpret_cast<const CMLogoutAck*>(
               &_CMLogoutAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(CMLogoutAck* other);
  friend void swap(CMLogoutAck& a, CMLogoutAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMLogoutAck* New() const final {
    return CreateMaybeMessage<CMLogoutAck>(NULL);
  }

  CMLogoutAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMLogoutAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const CMLogoutAck& from);
  void MergeFrom(const CMLogoutAck& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CMLogoutAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sUserId = 2;
  void clear_suserid();
  static const int kSUserIdFieldNumber = 2;
  const ::std::string& suserid() const;
  void set_suserid(const ::std::string& value);
  #if LANG_CXX11
  void set_suserid(::std::string&& value);
  #endif
  void set_suserid(const char* value);
  void set_suserid(const char* value, size_t size);
  ::std::string* mutable_suserid();
  ::std::string* release_suserid();
  void set_allocated_suserid(::std::string* suserid);

  // .im.ErrCode nErr = 1;
  void clear_nerr();
  static const int kNErrFieldNumber = 1;
  ::im::ErrCode nerr() const;
  void set_nerr(::im::ErrCode value);

  // @@protoc_insertion_point(class_scope:im.CMLogoutAck)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr suserid_;
  int nerr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_im_2ecm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMKickoutNotification : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:im.CMKickoutNotification) */ {
 public:
  CMKickoutNotification();
  virtual ~CMKickoutNotification();

  CMKickoutNotification(const CMKickoutNotification& from);

  inline CMKickoutNotification& operator=(const CMKickoutNotification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMKickoutNotification(CMKickoutNotification&& from) noexcept
    : CMKickoutNotification() {
    *this = ::std::move(from);
  }

  inline CMKickoutNotification& operator=(CMKickoutNotification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const CMKickoutNotification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMKickoutNotification* internal_default_instance() {
    return reinterpret_cast<const CMKickoutNotification*>(
               &_CMKickoutNotification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(CMKickoutNotification* other);
  friend void swap(CMKickoutNotification& a, CMKickoutNotification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMKickoutNotification* New() const final {
    return CreateMaybeMessage<CMKickoutNotification>(NULL);
  }

  CMKickoutNotification* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMKickoutNotification>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const CMKickoutNotification& from);
  void MergeFrom(const CMKickoutNotification& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CMKickoutNotification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sUserId = 1;
  void clear_suserid();
  static const int kSUserIdFieldNumber = 1;
  const ::std::string& suserid() const;
  void set_suserid(const ::std::string& value);
  #if LANG_CXX11
  void set_suserid(::std::string&& value);
  #endif
  void set_suserid(const char* value);
  void set_suserid(const char* value, size_t size);
  ::std::string* mutable_suserid();
  ::std::string* release_suserid();
  void set_allocated_suserid(::std::string* suserid);

  // string ip = 2;
  void clear_ip();
  static const int kIpFieldNumber = 2;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // uint32 port = 3;
  void clear_port();
  static const int kPortFieldNumber = 3;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:im.CMKickoutNotification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr suserid_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::uint32 port_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_im_2ecm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMLoginNotify : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:im.CMLoginNotify) */ {
 public:
  CMLoginNotify();
  virtual ~CMLoginNotify();

  CMLoginNotify(const CMLoginNotify& from);

  inline CMLoginNotify& operator=(const CMLoginNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMLoginNotify(CMLoginNotify&& from) noexcept
    : CMLoginNotify() {
    *this = ::std::move(from);
  }

  inline CMLoginNotify& operator=(CMLoginNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const CMLoginNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMLoginNotify* internal_default_instance() {
    return reinterpret_cast<const CMLoginNotify*>(
               &_CMLoginNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CMLoginNotify* other);
  friend void swap(CMLoginNotify& a, CMLoginNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMLoginNotify* New() const final {
    return CreateMaybeMessage<CMLoginNotify>(NULL);
  }

  CMLoginNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMLoginNotify>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const CMLoginNotify& from);
  void MergeFrom(const CMLoginNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CMLoginNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sUserId = 1;
  void clear_suserid();
  static const int kSUserIdFieldNumber = 1;
  const ::std::string& suserid() const;
  void set_suserid(const ::std::string& value);
  #if LANG_CXX11
  void set_suserid(::std::string&& value);
  #endif
  void set_suserid(const char* value);
  void set_suserid(const char* value, size_t size);
  ::std::string* mutable_suserid();
  ::std::string* release_suserid();
  void set_allocated_suserid(::std::string* suserid);

  // string sIp = 2;
  void clear_sip();
  static const int kSIpFieldNumber = 2;
  const ::std::string& sip() const;
  void set_sip(const ::std::string& value);
  #if LANG_CXX11
  void set_sip(::std::string&& value);
  #endif
  void set_sip(const char* value);
  void set_sip(const char* value, size_t size);
  ::std::string* mutable_sip();
  ::std::string* release_sip();
  void set_allocated_sip(::std::string* sip);

  // uint32 nPort = 3;
  void clear_nport();
  static const int kNPortFieldNumber = 3;
  ::google::protobuf::uint32 nport() const;
  void set_nport(::google::protobuf::uint32 value);

  // .im.CMLoginNotifyType notifyType = 4;
  void clear_notifytype();
  static const int kNotifyTypeFieldNumber = 4;
  ::im::CMLoginNotifyType notifytype() const;
  void set_notifytype(::im::CMLoginNotifyType value);

  // @@protoc_insertion_point(class_scope:im.CMLoginNotify)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr suserid_;
  ::google::protobuf::internal::ArenaStringPtr sip_;
  ::google::protobuf::uint32 nport_;
  int notifytype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_im_2ecm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMLoginNotifyAck : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:im.CMLoginNotifyAck) */ {
 public:
  CMLoginNotifyAck();
  virtual ~CMLoginNotifyAck();

  CMLoginNotifyAck(const CMLoginNotifyAck& from);

  inline CMLoginNotifyAck& operator=(const CMLoginNotifyAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMLoginNotifyAck(CMLoginNotifyAck&& from) noexcept
    : CMLoginNotifyAck() {
    *this = ::std::move(from);
  }

  inline CMLoginNotifyAck& operator=(CMLoginNotifyAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const CMLoginNotifyAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMLoginNotifyAck* internal_default_instance() {
    return reinterpret_cast<const CMLoginNotifyAck*>(
               &_CMLoginNotifyAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(CMLoginNotifyAck* other);
  friend void swap(CMLoginNotifyAck& a, CMLoginNotifyAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMLoginNotifyAck* New() const final {
    return CreateMaybeMessage<CMLoginNotifyAck>(NULL);
  }

  CMLoginNotifyAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMLoginNotifyAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const CMLoginNotifyAck& from);
  void MergeFrom(const CMLoginNotifyAck& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CMLoginNotifyAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sUserId = 1;
  void clear_suserid();
  static const int kSUserIdFieldNumber = 1;
  const ::std::string& suserid() const;
  void set_suserid(const ::std::string& value);
  #if LANG_CXX11
  void set_suserid(::std::string&& value);
  #endif
  void set_suserid(const char* value);
  void set_suserid(const char* value, size_t size);
  ::std::string* mutable_suserid();
  ::std::string* release_suserid();
  void set_allocated_suserid(::std::string* suserid);

  // .im.ErrCode nErr = 2;
  void clear_nerr();
  static const int kNErrFieldNumber = 2;
  ::im::ErrCode nerr() const;
  void set_nerr(::im::ErrCode value);

  // @@protoc_insertion_point(class_scope:im.CMLoginNotifyAck)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr suserid_;
  int nerr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_im_2ecm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoginCMNotify : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:im.LoginCMNotify) */ {
 public:
  LoginCMNotify();
  virtual ~LoginCMNotify();

  LoginCMNotify(const LoginCMNotify& from);

  inline LoginCMNotify& operator=(const LoginCMNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginCMNotify(LoginCMNotify&& from) noexcept
    : LoginCMNotify() {
    *this = ::std::move(from);
  }

  inline LoginCMNotify& operator=(LoginCMNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const LoginCMNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginCMNotify* internal_default_instance() {
    return reinterpret_cast<const LoginCMNotify*>(
               &_LoginCMNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(LoginCMNotify* other);
  friend void swap(LoginCMNotify& a, LoginCMNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginCMNotify* New() const final {
    return CreateMaybeMessage<LoginCMNotify>(NULL);
  }

  LoginCMNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoginCMNotify>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const LoginCMNotify& from);
  void MergeFrom(const LoginCMNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginCMNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sUserId = 1;
  void clear_suserid();
  static const int kSUserIdFieldNumber = 1;
  const ::std::string& suserid() const;
  void set_suserid(const ::std::string& value);
  #if LANG_CXX11
  void set_suserid(::std::string&& value);
  #endif
  void set_suserid(const char* value);
  void set_suserid(const char* value, size_t size);
  ::std::string* mutable_suserid();
  ::std::string* release_suserid();
  void set_allocated_suserid(::std::string* suserid);

  // .im.LoginCMNotifyType notifyType = 2;
  void clear_notifytype();
  static const int kNotifyTypeFieldNumber = 2;
  ::im::LoginCMNotifyType notifytype() const;
  void set_notifytype(::im::LoginCMNotifyType value);

  // @@protoc_insertion_point(class_scope:im.LoginCMNotify)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr suserid_;
  int notifytype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_im_2ecm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoginCMNotifyAck : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:im.LoginCMNotifyAck) */ {
 public:
  LoginCMNotifyAck();
  virtual ~LoginCMNotifyAck();

  LoginCMNotifyAck(const LoginCMNotifyAck& from);

  inline LoginCMNotifyAck& operator=(const LoginCMNotifyAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginCMNotifyAck(LoginCMNotifyAck&& from) noexcept
    : LoginCMNotifyAck() {
    *this = ::std::move(from);
  }

  inline LoginCMNotifyAck& operator=(LoginCMNotifyAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const LoginCMNotifyAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginCMNotifyAck* internal_default_instance() {
    return reinterpret_cast<const LoginCMNotifyAck*>(
               &_LoginCMNotifyAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(LoginCMNotifyAck* other);
  friend void swap(LoginCMNotifyAck& a, LoginCMNotifyAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginCMNotifyAck* New() const final {
    return CreateMaybeMessage<LoginCMNotifyAck>(NULL);
  }

  LoginCMNotifyAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoginCMNotifyAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const LoginCMNotifyAck& from);
  void MergeFrom(const LoginCMNotifyAck& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginCMNotifyAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sUserId = 1;
  void clear_suserid();
  static const int kSUserIdFieldNumber = 1;
  const ::std::string& suserid() const;
  void set_suserid(const ::std::string& value);
  #if LANG_CXX11
  void set_suserid(::std::string&& value);
  #endif
  void set_suserid(const char* value);
  void set_suserid(const char* value, size_t size);
  ::std::string* mutable_suserid();
  ::std::string* release_suserid();
  void set_allocated_suserid(::std::string* suserid);

  // .im.ErrCode nErr = 2;
  void clear_nerr();
  static const int kNErrFieldNumber = 2;
  ::im::ErrCode nerr() const;
  void set_nerr(::im::ErrCode value);

  // @@protoc_insertion_point(class_scope:im.LoginCMNotifyAck)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr suserid_;
  int nerr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_im_2ecm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMLoginTrans : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:im.CMLoginTrans) */ {
 public:
  CMLoginTrans();
  virtual ~CMLoginTrans();

  CMLoginTrans(const CMLoginTrans& from);

  inline CMLoginTrans& operator=(const CMLoginTrans& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMLoginTrans(CMLoginTrans&& from) noexcept
    : CMLoginTrans() {
    *this = ::std::move(from);
  }

  inline CMLoginTrans& operator=(CMLoginTrans&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const CMLoginTrans& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMLoginTrans* internal_default_instance() {
    return reinterpret_cast<const CMLoginTrans*>(
               &_CMLoginTrans_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(CMLoginTrans* other);
  friend void swap(CMLoginTrans& a, CMLoginTrans& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMLoginTrans* New() const final {
    return CreateMaybeMessage<CMLoginTrans>(NULL);
  }

  CMLoginTrans* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMLoginTrans>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const CMLoginTrans& from);
  void MergeFrom(const CMLoginTrans& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CMLoginTrans* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sUserId = 1;
  void clear_suserid();
  static const int kSUserIdFieldNumber = 1;
  const ::std::string& suserid() const;
  void set_suserid(const ::std::string& value);
  #if LANG_CXX11
  void set_suserid(::std::string&& value);
  #endif
  void set_suserid(const char* value);
  void set_suserid(const char* value, size_t size);
  ::std::string* mutable_suserid();
  ::std::string* release_suserid();
  void set_allocated_suserid(::std::string* suserid);

  // string sLoginToken = 2;
  void clear_slogintoken();
  static const int kSLoginTokenFieldNumber = 2;
  const ::std::string& slogintoken() const;
  void set_slogintoken(const ::std::string& value);
  #if LANG_CXX11
  void set_slogintoken(::std::string&& value);
  #endif
  void set_slogintoken(const char* value);
  void set_slogintoken(const char* value, size_t size);
  ::std::string* mutable_slogintoken();
  ::std::string* release_slogintoken();
  void set_allocated_slogintoken(::std::string* slogintoken);

  // string sDeviceToken = 3;
  void clear_sdevicetoken();
  static const int kSDeviceTokenFieldNumber = 3;
  const ::std::string& sdevicetoken() const;
  void set_sdevicetoken(const ::std::string& value);
  #if LANG_CXX11
  void set_sdevicetoken(::std::string&& value);
  #endif
  void set_sdevicetoken(const char* value);
  void set_sdevicetoken(const char* value, size_t size);
  ::std::string* mutable_sdevicetoken();
  ::std::string* release_sdevicetoken();
  void set_allocated_sdevicetoken(::std::string* sdevicetoken);

  // string sLoginIp = 5;
  void clear_sloginip();
  static const int kSLoginIpFieldNumber = 5;
  const ::std::string& sloginip() const;
  void set_sloginip(const ::std::string& value);
  #if LANG_CXX11
  void set_sloginip(::std::string&& value);
  #endif
  void set_sloginip(const char* value);
  void set_sloginip(const char* value, size_t size);
  ::std::string* mutable_sloginip();
  ::std::string* release_sloginip();
  void set_allocated_sloginip(::std::string* sloginip);

  // uint64 nLoginTime = 4;
  void clear_nlogintime();
  static const int kNLoginTimeFieldNumber = 4;
  ::google::protobuf::uint64 nlogintime() const;
  void set_nlogintime(::google::protobuf::uint64 value);

  // uint32 nLoginPort = 6;
  void clear_nloginport();
  static const int kNLoginPortFieldNumber = 6;
  ::google::protobuf::uint32 nloginport() const;
  void set_nloginport(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:im.CMLoginTrans)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr suserid_;
  ::google::protobuf::internal::ArenaStringPtr slogintoken_;
  ::google::protobuf::internal::ArenaStringPtr sdevicetoken_;
  ::google::protobuf::internal::ArenaStringPtr sloginip_;
  ::google::protobuf::uint64 nlogintime_;
  ::google::protobuf::uint32 nloginport_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_im_2ecm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMPHPLoginNotify : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:im.CMPHPLoginNotify) */ {
 public:
  CMPHPLoginNotify();
  virtual ~CMPHPLoginNotify();

  CMPHPLoginNotify(const CMPHPLoginNotify& from);

  inline CMPHPLoginNotify& operator=(const CMPHPLoginNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMPHPLoginNotify(CMPHPLoginNotify&& from) noexcept
    : CMPHPLoginNotify() {
    *this = ::std::move(from);
  }

  inline CMPHPLoginNotify& operator=(CMPHPLoginNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const CMPHPLoginNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMPHPLoginNotify* internal_default_instance() {
    return reinterpret_cast<const CMPHPLoginNotify*>(
               &_CMPHPLoginNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(CMPHPLoginNotify* other);
  friend void swap(CMPHPLoginNotify& a, CMPHPLoginNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMPHPLoginNotify* New() const final {
    return CreateMaybeMessage<CMPHPLoginNotify>(NULL);
  }

  CMPHPLoginNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMPHPLoginNotify>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const CMPHPLoginNotify& from);
  void MergeFrom(const CMPHPLoginNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CMPHPLoginNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sUserId = 1;
  void clear_suserid();
  static const int kSUserIdFieldNumber = 1;
  const ::std::string& suserid() const;
  void set_suserid(const ::std::string& value);
  #if LANG_CXX11
  void set_suserid(::std::string&& value);
  #endif
  void set_suserid(const char* value);
  void set_suserid(const char* value, size_t size);
  ::std::string* mutable_suserid();
  ::std::string* release_suserid();
  void set_allocated_suserid(::std::string* suserid);

  // string extend = 4;
  void clear_extend();
  static const int kExtendFieldNumber = 4;
  const ::std::string& extend() const;
  void set_extend(const ::std::string& value);
  #if LANG_CXX11
  void set_extend(::std::string&& value);
  #endif
  void set_extend(const char* value);
  void set_extend(const char* value, size_t size);
  ::std::string* mutable_extend();
  ::std::string* release_extend();
  void set_allocated_extend(::std::string* extend);

  // uint64 msgTime = 2;
  void clear_msgtime();
  static const int kMsgTimeFieldNumber = 2;
  ::google::protobuf::uint64 msgtime() const;
  void set_msgtime(::google::protobuf::uint64 value);

  // .im.PHPLoginNotifyType loginType = 3;
  void clear_logintype();
  static const int kLoginTypeFieldNumber = 3;
  ::im::PHPLoginNotifyType logintype() const;
  void set_logintype(::im::PHPLoginNotifyType value);

  // @@protoc_insertion_point(class_scope:im.CMPHPLoginNotify)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr suserid_;
  ::google::protobuf::internal::ArenaStringPtr extend_;
  ::google::protobuf::uint64 msgtime_;
  int logintype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_im_2ecm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMPHPLoginNotifyACK : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:im.CMPHPLoginNotifyACK) */ {
 public:
  CMPHPLoginNotifyACK();
  virtual ~CMPHPLoginNotifyACK();

  CMPHPLoginNotifyACK(const CMPHPLoginNotifyACK& from);

  inline CMPHPLoginNotifyACK& operator=(const CMPHPLoginNotifyACK& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMPHPLoginNotifyACK(CMPHPLoginNotifyACK&& from) noexcept
    : CMPHPLoginNotifyACK() {
    *this = ::std::move(from);
  }

  inline CMPHPLoginNotifyACK& operator=(CMPHPLoginNotifyACK&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const CMPHPLoginNotifyACK& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMPHPLoginNotifyACK* internal_default_instance() {
    return reinterpret_cast<const CMPHPLoginNotifyACK*>(
               &_CMPHPLoginNotifyACK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(CMPHPLoginNotifyACK* other);
  friend void swap(CMPHPLoginNotifyACK& a, CMPHPLoginNotifyACK& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMPHPLoginNotifyACK* New() const final {
    return CreateMaybeMessage<CMPHPLoginNotifyACK>(NULL);
  }

  CMPHPLoginNotifyACK* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMPHPLoginNotifyACK>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const CMPHPLoginNotifyACK& from);
  void MergeFrom(const CMPHPLoginNotifyACK& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CMPHPLoginNotifyACK* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sUserId = 1;
  void clear_suserid();
  static const int kSUserIdFieldNumber = 1;
  const ::std::string& suserid() const;
  void set_suserid(const ::std::string& value);
  #if LANG_CXX11
  void set_suserid(::std::string&& value);
  #endif
  void set_suserid(const char* value);
  void set_suserid(const char* value, size_t size);
  ::std::string* mutable_suserid();
  ::std::string* release_suserid();
  void set_allocated_suserid(::std::string* suserid);

  // uint64 msgTime = 2;
  void clear_msgtime();
  static const int kMsgTimeFieldNumber = 2;
  ::google::protobuf::uint64 msgtime() const;
  void set_msgtime(::google::protobuf::uint64 value);

  // .im.ErrCode nErr = 3;
  void clear_nerr();
  static const int kNErrFieldNumber = 3;
  ::im::ErrCode nerr() const;
  void set_nerr(::im::ErrCode value);

  // @@protoc_insertion_point(class_scope:im.CMPHPLoginNotifyACK)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr suserid_;
  ::google::protobuf::uint64 msgtime_;
  int nerr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_im_2ecm_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CMLogin

// string sUserId = 1;
inline void CMLogin::clear_suserid() {
  suserid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CMLogin::suserid() const {
  // @@protoc_insertion_point(field_get:im.CMLogin.sUserId)
  return suserid_.GetNoArena();
}
inline void CMLogin::set_suserid(const ::std::string& value) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.CMLogin.sUserId)
}
#if LANG_CXX11
inline void CMLogin::set_suserid(::std::string&& value) {
  
  suserid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.CMLogin.sUserId)
}
#endif
inline void CMLogin::set_suserid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.CMLogin.sUserId)
}
inline void CMLogin::set_suserid(const char* value, size_t size) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.CMLogin.sUserId)
}
inline ::std::string* CMLogin::mutable_suserid() {
  
  // @@protoc_insertion_point(field_mutable:im.CMLogin.sUserId)
  return suserid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMLogin::release_suserid() {
  // @@protoc_insertion_point(field_release:im.CMLogin.sUserId)
  
  return suserid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMLogin::set_allocated_suserid(::std::string* suserid) {
  if (suserid != NULL) {
    
  } else {
    
  }
  suserid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), suserid);
  // @@protoc_insertion_point(field_set_allocated:im.CMLogin.sUserId)
}

// string sLoginToken = 2;
inline void CMLogin::clear_slogintoken() {
  slogintoken_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CMLogin::slogintoken() const {
  // @@protoc_insertion_point(field_get:im.CMLogin.sLoginToken)
  return slogintoken_.GetNoArena();
}
inline void CMLogin::set_slogintoken(const ::std::string& value) {
  
  slogintoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.CMLogin.sLoginToken)
}
#if LANG_CXX11
inline void CMLogin::set_slogintoken(::std::string&& value) {
  
  slogintoken_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.CMLogin.sLoginToken)
}
#endif
inline void CMLogin::set_slogintoken(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  slogintoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.CMLogin.sLoginToken)
}
inline void CMLogin::set_slogintoken(const char* value, size_t size) {
  
  slogintoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.CMLogin.sLoginToken)
}
inline ::std::string* CMLogin::mutable_slogintoken() {
  
  // @@protoc_insertion_point(field_mutable:im.CMLogin.sLoginToken)
  return slogintoken_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMLogin::release_slogintoken() {
  // @@protoc_insertion_point(field_release:im.CMLogin.sLoginToken)
  
  return slogintoken_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMLogin::set_allocated_slogintoken(::std::string* slogintoken) {
  if (slogintoken != NULL) {
    
  } else {
    
  }
  slogintoken_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), slogintoken);
  // @@protoc_insertion_point(field_set_allocated:im.CMLogin.sLoginToken)
}

// string sDeviceToken = 3;
inline void CMLogin::clear_sdevicetoken() {
  sdevicetoken_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CMLogin::sdevicetoken() const {
  // @@protoc_insertion_point(field_get:im.CMLogin.sDeviceToken)
  return sdevicetoken_.GetNoArena();
}
inline void CMLogin::set_sdevicetoken(const ::std::string& value) {
  
  sdevicetoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.CMLogin.sDeviceToken)
}
#if LANG_CXX11
inline void CMLogin::set_sdevicetoken(::std::string&& value) {
  
  sdevicetoken_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.CMLogin.sDeviceToken)
}
#endif
inline void CMLogin::set_sdevicetoken(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sdevicetoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.CMLogin.sDeviceToken)
}
inline void CMLogin::set_sdevicetoken(const char* value, size_t size) {
  
  sdevicetoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.CMLogin.sDeviceToken)
}
inline ::std::string* CMLogin::mutable_sdevicetoken() {
  
  // @@protoc_insertion_point(field_mutable:im.CMLogin.sDeviceToken)
  return sdevicetoken_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMLogin::release_sdevicetoken() {
  // @@protoc_insertion_point(field_release:im.CMLogin.sDeviceToken)
  
  return sdevicetoken_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMLogin::set_allocated_sdevicetoken(::std::string* sdevicetoken) {
  if (sdevicetoken != NULL) {
    
  } else {
    
  }
  sdevicetoken_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sdevicetoken);
  // @@protoc_insertion_point(field_set_allocated:im.CMLogin.sDeviceToken)
}

// uint64 nLoginTime = 4;
inline void CMLogin::clear_nlogintime() {
  nlogintime_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 CMLogin::nlogintime() const {
  // @@protoc_insertion_point(field_get:im.CMLogin.nLoginTime)
  return nlogintime_;
}
inline void CMLogin::set_nlogintime(::google::protobuf::uint64 value) {
  
  nlogintime_ = value;
  // @@protoc_insertion_point(field_set:im.CMLogin.nLoginTime)
}

// -------------------------------------------------------------------

// CMLoginAck

// string sUserId = 1;
inline void CMLoginAck::clear_suserid() {
  suserid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CMLoginAck::suserid() const {
  // @@protoc_insertion_point(field_get:im.CMLoginAck.sUserId)
  return suserid_.GetNoArena();
}
inline void CMLoginAck::set_suserid(const ::std::string& value) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.CMLoginAck.sUserId)
}
#if LANG_CXX11
inline void CMLoginAck::set_suserid(::std::string&& value) {
  
  suserid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.CMLoginAck.sUserId)
}
#endif
inline void CMLoginAck::set_suserid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.CMLoginAck.sUserId)
}
inline void CMLoginAck::set_suserid(const char* value, size_t size) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.CMLoginAck.sUserId)
}
inline ::std::string* CMLoginAck::mutable_suserid() {
  
  // @@protoc_insertion_point(field_mutable:im.CMLoginAck.sUserId)
  return suserid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMLoginAck::release_suserid() {
  // @@protoc_insertion_point(field_release:im.CMLoginAck.sUserId)
  
  return suserid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMLoginAck::set_allocated_suserid(::std::string* suserid) {
  if (suserid != NULL) {
    
  } else {
    
  }
  suserid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), suserid);
  // @@protoc_insertion_point(field_set_allocated:im.CMLoginAck.sUserId)
}

// .im.ErrCode nErr = 2;
inline void CMLoginAck::clear_nerr() {
  nerr_ = 0;
}
inline ::im::ErrCode CMLoginAck::nerr() const {
  // @@protoc_insertion_point(field_get:im.CMLoginAck.nErr)
  return static_cast< ::im::ErrCode >(nerr_);
}
inline void CMLoginAck::set_nerr(::im::ErrCode value) {
  
  nerr_ = value;
  // @@protoc_insertion_point(field_set:im.CMLoginAck.nErr)
}

// uint64 nLastLoginTime = 3;
inline void CMLoginAck::clear_nlastlogintime() {
  nlastlogintime_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 CMLoginAck::nlastlogintime() const {
  // @@protoc_insertion_point(field_get:im.CMLoginAck.nLastLoginTime)
  return nlastlogintime_;
}
inline void CMLoginAck::set_nlastlogintime(::google::protobuf::uint64 value) {
  
  nlastlogintime_ = value;
  // @@protoc_insertion_point(field_set:im.CMLoginAck.nLastLoginTime)
}

// -------------------------------------------------------------------

// CMLogout

// string sUserId = 1;
inline void CMLogout::clear_suserid() {
  suserid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CMLogout::suserid() const {
  // @@protoc_insertion_point(field_get:im.CMLogout.sUserId)
  return suserid_.GetNoArena();
}
inline void CMLogout::set_suserid(const ::std::string& value) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.CMLogout.sUserId)
}
#if LANG_CXX11
inline void CMLogout::set_suserid(::std::string&& value) {
  
  suserid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.CMLogout.sUserId)
}
#endif
inline void CMLogout::set_suserid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.CMLogout.sUserId)
}
inline void CMLogout::set_suserid(const char* value, size_t size) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.CMLogout.sUserId)
}
inline ::std::string* CMLogout::mutable_suserid() {
  
  // @@protoc_insertion_point(field_mutable:im.CMLogout.sUserId)
  return suserid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMLogout::release_suserid() {
  // @@protoc_insertion_point(field_release:im.CMLogout.sUserId)
  
  return suserid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMLogout::set_allocated_suserid(::std::string* suserid) {
  if (suserid != NULL) {
    
  } else {
    
  }
  suserid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), suserid);
  // @@protoc_insertion_point(field_set_allocated:im.CMLogout.sUserId)
}

// uint32 nDeviceType = 2;
inline void CMLogout::clear_ndevicetype() {
  ndevicetype_ = 0u;
}
inline ::google::protobuf::uint32 CMLogout::ndevicetype() const {
  // @@protoc_insertion_point(field_get:im.CMLogout.nDeviceType)
  return ndevicetype_;
}
inline void CMLogout::set_ndevicetype(::google::protobuf::uint32 value) {
  
  ndevicetype_ = value;
  // @@protoc_insertion_point(field_set:im.CMLogout.nDeviceType)
}

// -------------------------------------------------------------------

// CMLogoutAck

// .im.ErrCode nErr = 1;
inline void CMLogoutAck::clear_nerr() {
  nerr_ = 0;
}
inline ::im::ErrCode CMLogoutAck::nerr() const {
  // @@protoc_insertion_point(field_get:im.CMLogoutAck.nErr)
  return static_cast< ::im::ErrCode >(nerr_);
}
inline void CMLogoutAck::set_nerr(::im::ErrCode value) {
  
  nerr_ = value;
  // @@protoc_insertion_point(field_set:im.CMLogoutAck.nErr)
}

// string sUserId = 2;
inline void CMLogoutAck::clear_suserid() {
  suserid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CMLogoutAck::suserid() const {
  // @@protoc_insertion_point(field_get:im.CMLogoutAck.sUserId)
  return suserid_.GetNoArena();
}
inline void CMLogoutAck::set_suserid(const ::std::string& value) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.CMLogoutAck.sUserId)
}
#if LANG_CXX11
inline void CMLogoutAck::set_suserid(::std::string&& value) {
  
  suserid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.CMLogoutAck.sUserId)
}
#endif
inline void CMLogoutAck::set_suserid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.CMLogoutAck.sUserId)
}
inline void CMLogoutAck::set_suserid(const char* value, size_t size) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.CMLogoutAck.sUserId)
}
inline ::std::string* CMLogoutAck::mutable_suserid() {
  
  // @@protoc_insertion_point(field_mutable:im.CMLogoutAck.sUserId)
  return suserid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMLogoutAck::release_suserid() {
  // @@protoc_insertion_point(field_release:im.CMLogoutAck.sUserId)
  
  return suserid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMLogoutAck::set_allocated_suserid(::std::string* suserid) {
  if (suserid != NULL) {
    
  } else {
    
  }
  suserid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), suserid);
  // @@protoc_insertion_point(field_set_allocated:im.CMLogoutAck.sUserId)
}

// -------------------------------------------------------------------

// CMKickoutNotification

// string sUserId = 1;
inline void CMKickoutNotification::clear_suserid() {
  suserid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CMKickoutNotification::suserid() const {
  // @@protoc_insertion_point(field_get:im.CMKickoutNotification.sUserId)
  return suserid_.GetNoArena();
}
inline void CMKickoutNotification::set_suserid(const ::std::string& value) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.CMKickoutNotification.sUserId)
}
#if LANG_CXX11
inline void CMKickoutNotification::set_suserid(::std::string&& value) {
  
  suserid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.CMKickoutNotification.sUserId)
}
#endif
inline void CMKickoutNotification::set_suserid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.CMKickoutNotification.sUserId)
}
inline void CMKickoutNotification::set_suserid(const char* value, size_t size) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.CMKickoutNotification.sUserId)
}
inline ::std::string* CMKickoutNotification::mutable_suserid() {
  
  // @@protoc_insertion_point(field_mutable:im.CMKickoutNotification.sUserId)
  return suserid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMKickoutNotification::release_suserid() {
  // @@protoc_insertion_point(field_release:im.CMKickoutNotification.sUserId)
  
  return suserid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMKickoutNotification::set_allocated_suserid(::std::string* suserid) {
  if (suserid != NULL) {
    
  } else {
    
  }
  suserid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), suserid);
  // @@protoc_insertion_point(field_set_allocated:im.CMKickoutNotification.sUserId)
}

// string ip = 2;
inline void CMKickoutNotification::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CMKickoutNotification::ip() const {
  // @@protoc_insertion_point(field_get:im.CMKickoutNotification.ip)
  return ip_.GetNoArena();
}
inline void CMKickoutNotification::set_ip(const ::std::string& value) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.CMKickoutNotification.ip)
}
#if LANG_CXX11
inline void CMKickoutNotification::set_ip(::std::string&& value) {
  
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.CMKickoutNotification.ip)
}
#endif
inline void CMKickoutNotification::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.CMKickoutNotification.ip)
}
inline void CMKickoutNotification::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.CMKickoutNotification.ip)
}
inline ::std::string* CMKickoutNotification::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:im.CMKickoutNotification.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMKickoutNotification::release_ip() {
  // @@protoc_insertion_point(field_release:im.CMKickoutNotification.ip)
  
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMKickoutNotification::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:im.CMKickoutNotification.ip)
}

// uint32 port = 3;
inline void CMKickoutNotification::clear_port() {
  port_ = 0u;
}
inline ::google::protobuf::uint32 CMKickoutNotification::port() const {
  // @@protoc_insertion_point(field_get:im.CMKickoutNotification.port)
  return port_;
}
inline void CMKickoutNotification::set_port(::google::protobuf::uint32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:im.CMKickoutNotification.port)
}

// -------------------------------------------------------------------

// CMLoginNotify

// string sUserId = 1;
inline void CMLoginNotify::clear_suserid() {
  suserid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CMLoginNotify::suserid() const {
  // @@protoc_insertion_point(field_get:im.CMLoginNotify.sUserId)
  return suserid_.GetNoArena();
}
inline void CMLoginNotify::set_suserid(const ::std::string& value) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.CMLoginNotify.sUserId)
}
#if LANG_CXX11
inline void CMLoginNotify::set_suserid(::std::string&& value) {
  
  suserid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.CMLoginNotify.sUserId)
}
#endif
inline void CMLoginNotify::set_suserid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.CMLoginNotify.sUserId)
}
inline void CMLoginNotify::set_suserid(const char* value, size_t size) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.CMLoginNotify.sUserId)
}
inline ::std::string* CMLoginNotify::mutable_suserid() {
  
  // @@protoc_insertion_point(field_mutable:im.CMLoginNotify.sUserId)
  return suserid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMLoginNotify::release_suserid() {
  // @@protoc_insertion_point(field_release:im.CMLoginNotify.sUserId)
  
  return suserid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMLoginNotify::set_allocated_suserid(::std::string* suserid) {
  if (suserid != NULL) {
    
  } else {
    
  }
  suserid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), suserid);
  // @@protoc_insertion_point(field_set_allocated:im.CMLoginNotify.sUserId)
}

// string sIp = 2;
inline void CMLoginNotify::clear_sip() {
  sip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CMLoginNotify::sip() const {
  // @@protoc_insertion_point(field_get:im.CMLoginNotify.sIp)
  return sip_.GetNoArena();
}
inline void CMLoginNotify::set_sip(const ::std::string& value) {
  
  sip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.CMLoginNotify.sIp)
}
#if LANG_CXX11
inline void CMLoginNotify::set_sip(::std::string&& value) {
  
  sip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.CMLoginNotify.sIp)
}
#endif
inline void CMLoginNotify::set_sip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.CMLoginNotify.sIp)
}
inline void CMLoginNotify::set_sip(const char* value, size_t size) {
  
  sip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.CMLoginNotify.sIp)
}
inline ::std::string* CMLoginNotify::mutable_sip() {
  
  // @@protoc_insertion_point(field_mutable:im.CMLoginNotify.sIp)
  return sip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMLoginNotify::release_sip() {
  // @@protoc_insertion_point(field_release:im.CMLoginNotify.sIp)
  
  return sip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMLoginNotify::set_allocated_sip(::std::string* sip) {
  if (sip != NULL) {
    
  } else {
    
  }
  sip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sip);
  // @@protoc_insertion_point(field_set_allocated:im.CMLoginNotify.sIp)
}

// uint32 nPort = 3;
inline void CMLoginNotify::clear_nport() {
  nport_ = 0u;
}
inline ::google::protobuf::uint32 CMLoginNotify::nport() const {
  // @@protoc_insertion_point(field_get:im.CMLoginNotify.nPort)
  return nport_;
}
inline void CMLoginNotify::set_nport(::google::protobuf::uint32 value) {
  
  nport_ = value;
  // @@protoc_insertion_point(field_set:im.CMLoginNotify.nPort)
}

// .im.CMLoginNotifyType notifyType = 4;
inline void CMLoginNotify::clear_notifytype() {
  notifytype_ = 0;
}
inline ::im::CMLoginNotifyType CMLoginNotify::notifytype() const {
  // @@protoc_insertion_point(field_get:im.CMLoginNotify.notifyType)
  return static_cast< ::im::CMLoginNotifyType >(notifytype_);
}
inline void CMLoginNotify::set_notifytype(::im::CMLoginNotifyType value) {
  
  notifytype_ = value;
  // @@protoc_insertion_point(field_set:im.CMLoginNotify.notifyType)
}

// -------------------------------------------------------------------

// CMLoginNotifyAck

// string sUserId = 1;
inline void CMLoginNotifyAck::clear_suserid() {
  suserid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CMLoginNotifyAck::suserid() const {
  // @@protoc_insertion_point(field_get:im.CMLoginNotifyAck.sUserId)
  return suserid_.GetNoArena();
}
inline void CMLoginNotifyAck::set_suserid(const ::std::string& value) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.CMLoginNotifyAck.sUserId)
}
#if LANG_CXX11
inline void CMLoginNotifyAck::set_suserid(::std::string&& value) {
  
  suserid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.CMLoginNotifyAck.sUserId)
}
#endif
inline void CMLoginNotifyAck::set_suserid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.CMLoginNotifyAck.sUserId)
}
inline void CMLoginNotifyAck::set_suserid(const char* value, size_t size) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.CMLoginNotifyAck.sUserId)
}
inline ::std::string* CMLoginNotifyAck::mutable_suserid() {
  
  // @@protoc_insertion_point(field_mutable:im.CMLoginNotifyAck.sUserId)
  return suserid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMLoginNotifyAck::release_suserid() {
  // @@protoc_insertion_point(field_release:im.CMLoginNotifyAck.sUserId)
  
  return suserid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMLoginNotifyAck::set_allocated_suserid(::std::string* suserid) {
  if (suserid != NULL) {
    
  } else {
    
  }
  suserid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), suserid);
  // @@protoc_insertion_point(field_set_allocated:im.CMLoginNotifyAck.sUserId)
}

// .im.ErrCode nErr = 2;
inline void CMLoginNotifyAck::clear_nerr() {
  nerr_ = 0;
}
inline ::im::ErrCode CMLoginNotifyAck::nerr() const {
  // @@protoc_insertion_point(field_get:im.CMLoginNotifyAck.nErr)
  return static_cast< ::im::ErrCode >(nerr_);
}
inline void CMLoginNotifyAck::set_nerr(::im::ErrCode value) {
  
  nerr_ = value;
  // @@protoc_insertion_point(field_set:im.CMLoginNotifyAck.nErr)
}

// -------------------------------------------------------------------

// LoginCMNotify

// string sUserId = 1;
inline void LoginCMNotify::clear_suserid() {
  suserid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginCMNotify::suserid() const {
  // @@protoc_insertion_point(field_get:im.LoginCMNotify.sUserId)
  return suserid_.GetNoArena();
}
inline void LoginCMNotify::set_suserid(const ::std::string& value) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.LoginCMNotify.sUserId)
}
#if LANG_CXX11
inline void LoginCMNotify::set_suserid(::std::string&& value) {
  
  suserid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.LoginCMNotify.sUserId)
}
#endif
inline void LoginCMNotify::set_suserid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.LoginCMNotify.sUserId)
}
inline void LoginCMNotify::set_suserid(const char* value, size_t size) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.LoginCMNotify.sUserId)
}
inline ::std::string* LoginCMNotify::mutable_suserid() {
  
  // @@protoc_insertion_point(field_mutable:im.LoginCMNotify.sUserId)
  return suserid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginCMNotify::release_suserid() {
  // @@protoc_insertion_point(field_release:im.LoginCMNotify.sUserId)
  
  return suserid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginCMNotify::set_allocated_suserid(::std::string* suserid) {
  if (suserid != NULL) {
    
  } else {
    
  }
  suserid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), suserid);
  // @@protoc_insertion_point(field_set_allocated:im.LoginCMNotify.sUserId)
}

// .im.LoginCMNotifyType notifyType = 2;
inline void LoginCMNotify::clear_notifytype() {
  notifytype_ = 0;
}
inline ::im::LoginCMNotifyType LoginCMNotify::notifytype() const {
  // @@protoc_insertion_point(field_get:im.LoginCMNotify.notifyType)
  return static_cast< ::im::LoginCMNotifyType >(notifytype_);
}
inline void LoginCMNotify::set_notifytype(::im::LoginCMNotifyType value) {
  
  notifytype_ = value;
  // @@protoc_insertion_point(field_set:im.LoginCMNotify.notifyType)
}

// -------------------------------------------------------------------

// LoginCMNotifyAck

// string sUserId = 1;
inline void LoginCMNotifyAck::clear_suserid() {
  suserid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginCMNotifyAck::suserid() const {
  // @@protoc_insertion_point(field_get:im.LoginCMNotifyAck.sUserId)
  return suserid_.GetNoArena();
}
inline void LoginCMNotifyAck::set_suserid(const ::std::string& value) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.LoginCMNotifyAck.sUserId)
}
#if LANG_CXX11
inline void LoginCMNotifyAck::set_suserid(::std::string&& value) {
  
  suserid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.LoginCMNotifyAck.sUserId)
}
#endif
inline void LoginCMNotifyAck::set_suserid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.LoginCMNotifyAck.sUserId)
}
inline void LoginCMNotifyAck::set_suserid(const char* value, size_t size) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.LoginCMNotifyAck.sUserId)
}
inline ::std::string* LoginCMNotifyAck::mutable_suserid() {
  
  // @@protoc_insertion_point(field_mutable:im.LoginCMNotifyAck.sUserId)
  return suserid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginCMNotifyAck::release_suserid() {
  // @@protoc_insertion_point(field_release:im.LoginCMNotifyAck.sUserId)
  
  return suserid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginCMNotifyAck::set_allocated_suserid(::std::string* suserid) {
  if (suserid != NULL) {
    
  } else {
    
  }
  suserid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), suserid);
  // @@protoc_insertion_point(field_set_allocated:im.LoginCMNotifyAck.sUserId)
}

// .im.ErrCode nErr = 2;
inline void LoginCMNotifyAck::clear_nerr() {
  nerr_ = 0;
}
inline ::im::ErrCode LoginCMNotifyAck::nerr() const {
  // @@protoc_insertion_point(field_get:im.LoginCMNotifyAck.nErr)
  return static_cast< ::im::ErrCode >(nerr_);
}
inline void LoginCMNotifyAck::set_nerr(::im::ErrCode value) {
  
  nerr_ = value;
  // @@protoc_insertion_point(field_set:im.LoginCMNotifyAck.nErr)
}

// -------------------------------------------------------------------

// CMLoginTrans

// string sUserId = 1;
inline void CMLoginTrans::clear_suserid() {
  suserid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CMLoginTrans::suserid() const {
  // @@protoc_insertion_point(field_get:im.CMLoginTrans.sUserId)
  return suserid_.GetNoArena();
}
inline void CMLoginTrans::set_suserid(const ::std::string& value) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.CMLoginTrans.sUserId)
}
#if LANG_CXX11
inline void CMLoginTrans::set_suserid(::std::string&& value) {
  
  suserid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.CMLoginTrans.sUserId)
}
#endif
inline void CMLoginTrans::set_suserid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.CMLoginTrans.sUserId)
}
inline void CMLoginTrans::set_suserid(const char* value, size_t size) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.CMLoginTrans.sUserId)
}
inline ::std::string* CMLoginTrans::mutable_suserid() {
  
  // @@protoc_insertion_point(field_mutable:im.CMLoginTrans.sUserId)
  return suserid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMLoginTrans::release_suserid() {
  // @@protoc_insertion_point(field_release:im.CMLoginTrans.sUserId)
  
  return suserid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMLoginTrans::set_allocated_suserid(::std::string* suserid) {
  if (suserid != NULL) {
    
  } else {
    
  }
  suserid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), suserid);
  // @@protoc_insertion_point(field_set_allocated:im.CMLoginTrans.sUserId)
}

// string sLoginToken = 2;
inline void CMLoginTrans::clear_slogintoken() {
  slogintoken_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CMLoginTrans::slogintoken() const {
  // @@protoc_insertion_point(field_get:im.CMLoginTrans.sLoginToken)
  return slogintoken_.GetNoArena();
}
inline void CMLoginTrans::set_slogintoken(const ::std::string& value) {
  
  slogintoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.CMLoginTrans.sLoginToken)
}
#if LANG_CXX11
inline void CMLoginTrans::set_slogintoken(::std::string&& value) {
  
  slogintoken_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.CMLoginTrans.sLoginToken)
}
#endif
inline void CMLoginTrans::set_slogintoken(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  slogintoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.CMLoginTrans.sLoginToken)
}
inline void CMLoginTrans::set_slogintoken(const char* value, size_t size) {
  
  slogintoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.CMLoginTrans.sLoginToken)
}
inline ::std::string* CMLoginTrans::mutable_slogintoken() {
  
  // @@protoc_insertion_point(field_mutable:im.CMLoginTrans.sLoginToken)
  return slogintoken_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMLoginTrans::release_slogintoken() {
  // @@protoc_insertion_point(field_release:im.CMLoginTrans.sLoginToken)
  
  return slogintoken_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMLoginTrans::set_allocated_slogintoken(::std::string* slogintoken) {
  if (slogintoken != NULL) {
    
  } else {
    
  }
  slogintoken_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), slogintoken);
  // @@protoc_insertion_point(field_set_allocated:im.CMLoginTrans.sLoginToken)
}

// string sDeviceToken = 3;
inline void CMLoginTrans::clear_sdevicetoken() {
  sdevicetoken_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CMLoginTrans::sdevicetoken() const {
  // @@protoc_insertion_point(field_get:im.CMLoginTrans.sDeviceToken)
  return sdevicetoken_.GetNoArena();
}
inline void CMLoginTrans::set_sdevicetoken(const ::std::string& value) {
  
  sdevicetoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.CMLoginTrans.sDeviceToken)
}
#if LANG_CXX11
inline void CMLoginTrans::set_sdevicetoken(::std::string&& value) {
  
  sdevicetoken_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.CMLoginTrans.sDeviceToken)
}
#endif
inline void CMLoginTrans::set_sdevicetoken(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sdevicetoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.CMLoginTrans.sDeviceToken)
}
inline void CMLoginTrans::set_sdevicetoken(const char* value, size_t size) {
  
  sdevicetoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.CMLoginTrans.sDeviceToken)
}
inline ::std::string* CMLoginTrans::mutable_sdevicetoken() {
  
  // @@protoc_insertion_point(field_mutable:im.CMLoginTrans.sDeviceToken)
  return sdevicetoken_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMLoginTrans::release_sdevicetoken() {
  // @@protoc_insertion_point(field_release:im.CMLoginTrans.sDeviceToken)
  
  return sdevicetoken_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMLoginTrans::set_allocated_sdevicetoken(::std::string* sdevicetoken) {
  if (sdevicetoken != NULL) {
    
  } else {
    
  }
  sdevicetoken_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sdevicetoken);
  // @@protoc_insertion_point(field_set_allocated:im.CMLoginTrans.sDeviceToken)
}

// uint64 nLoginTime = 4;
inline void CMLoginTrans::clear_nlogintime() {
  nlogintime_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 CMLoginTrans::nlogintime() const {
  // @@protoc_insertion_point(field_get:im.CMLoginTrans.nLoginTime)
  return nlogintime_;
}
inline void CMLoginTrans::set_nlogintime(::google::protobuf::uint64 value) {
  
  nlogintime_ = value;
  // @@protoc_insertion_point(field_set:im.CMLoginTrans.nLoginTime)
}

// string sLoginIp = 5;
inline void CMLoginTrans::clear_sloginip() {
  sloginip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CMLoginTrans::sloginip() const {
  // @@protoc_insertion_point(field_get:im.CMLoginTrans.sLoginIp)
  return sloginip_.GetNoArena();
}
inline void CMLoginTrans::set_sloginip(const ::std::string& value) {
  
  sloginip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.CMLoginTrans.sLoginIp)
}
#if LANG_CXX11
inline void CMLoginTrans::set_sloginip(::std::string&& value) {
  
  sloginip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.CMLoginTrans.sLoginIp)
}
#endif
inline void CMLoginTrans::set_sloginip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sloginip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.CMLoginTrans.sLoginIp)
}
inline void CMLoginTrans::set_sloginip(const char* value, size_t size) {
  
  sloginip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.CMLoginTrans.sLoginIp)
}
inline ::std::string* CMLoginTrans::mutable_sloginip() {
  
  // @@protoc_insertion_point(field_mutable:im.CMLoginTrans.sLoginIp)
  return sloginip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMLoginTrans::release_sloginip() {
  // @@protoc_insertion_point(field_release:im.CMLoginTrans.sLoginIp)
  
  return sloginip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMLoginTrans::set_allocated_sloginip(::std::string* sloginip) {
  if (sloginip != NULL) {
    
  } else {
    
  }
  sloginip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sloginip);
  // @@protoc_insertion_point(field_set_allocated:im.CMLoginTrans.sLoginIp)
}

// uint32 nLoginPort = 6;
inline void CMLoginTrans::clear_nloginport() {
  nloginport_ = 0u;
}
inline ::google::protobuf::uint32 CMLoginTrans::nloginport() const {
  // @@protoc_insertion_point(field_get:im.CMLoginTrans.nLoginPort)
  return nloginport_;
}
inline void CMLoginTrans::set_nloginport(::google::protobuf::uint32 value) {
  
  nloginport_ = value;
  // @@protoc_insertion_point(field_set:im.CMLoginTrans.nLoginPort)
}

// -------------------------------------------------------------------

// CMPHPLoginNotify

// string sUserId = 1;
inline void CMPHPLoginNotify::clear_suserid() {
  suserid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CMPHPLoginNotify::suserid() const {
  // @@protoc_insertion_point(field_get:im.CMPHPLoginNotify.sUserId)
  return suserid_.GetNoArena();
}
inline void CMPHPLoginNotify::set_suserid(const ::std::string& value) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.CMPHPLoginNotify.sUserId)
}
#if LANG_CXX11
inline void CMPHPLoginNotify::set_suserid(::std::string&& value) {
  
  suserid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.CMPHPLoginNotify.sUserId)
}
#endif
inline void CMPHPLoginNotify::set_suserid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.CMPHPLoginNotify.sUserId)
}
inline void CMPHPLoginNotify::set_suserid(const char* value, size_t size) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.CMPHPLoginNotify.sUserId)
}
inline ::std::string* CMPHPLoginNotify::mutable_suserid() {
  
  // @@protoc_insertion_point(field_mutable:im.CMPHPLoginNotify.sUserId)
  return suserid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMPHPLoginNotify::release_suserid() {
  // @@protoc_insertion_point(field_release:im.CMPHPLoginNotify.sUserId)
  
  return suserid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMPHPLoginNotify::set_allocated_suserid(::std::string* suserid) {
  if (suserid != NULL) {
    
  } else {
    
  }
  suserid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), suserid);
  // @@protoc_insertion_point(field_set_allocated:im.CMPHPLoginNotify.sUserId)
}

// uint64 msgTime = 2;
inline void CMPHPLoginNotify::clear_msgtime() {
  msgtime_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 CMPHPLoginNotify::msgtime() const {
  // @@protoc_insertion_point(field_get:im.CMPHPLoginNotify.msgTime)
  return msgtime_;
}
inline void CMPHPLoginNotify::set_msgtime(::google::protobuf::uint64 value) {
  
  msgtime_ = value;
  // @@protoc_insertion_point(field_set:im.CMPHPLoginNotify.msgTime)
}

// .im.PHPLoginNotifyType loginType = 3;
inline void CMPHPLoginNotify::clear_logintype() {
  logintype_ = 0;
}
inline ::im::PHPLoginNotifyType CMPHPLoginNotify::logintype() const {
  // @@protoc_insertion_point(field_get:im.CMPHPLoginNotify.loginType)
  return static_cast< ::im::PHPLoginNotifyType >(logintype_);
}
inline void CMPHPLoginNotify::set_logintype(::im::PHPLoginNotifyType value) {
  
  logintype_ = value;
  // @@protoc_insertion_point(field_set:im.CMPHPLoginNotify.loginType)
}

// string extend = 4;
inline void CMPHPLoginNotify::clear_extend() {
  extend_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CMPHPLoginNotify::extend() const {
  // @@protoc_insertion_point(field_get:im.CMPHPLoginNotify.extend)
  return extend_.GetNoArena();
}
inline void CMPHPLoginNotify::set_extend(const ::std::string& value) {
  
  extend_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.CMPHPLoginNotify.extend)
}
#if LANG_CXX11
inline void CMPHPLoginNotify::set_extend(::std::string&& value) {
  
  extend_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.CMPHPLoginNotify.extend)
}
#endif
inline void CMPHPLoginNotify::set_extend(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  extend_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.CMPHPLoginNotify.extend)
}
inline void CMPHPLoginNotify::set_extend(const char* value, size_t size) {
  
  extend_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.CMPHPLoginNotify.extend)
}
inline ::std::string* CMPHPLoginNotify::mutable_extend() {
  
  // @@protoc_insertion_point(field_mutable:im.CMPHPLoginNotify.extend)
  return extend_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMPHPLoginNotify::release_extend() {
  // @@protoc_insertion_point(field_release:im.CMPHPLoginNotify.extend)
  
  return extend_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMPHPLoginNotify::set_allocated_extend(::std::string* extend) {
  if (extend != NULL) {
    
  } else {
    
  }
  extend_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extend);
  // @@protoc_insertion_point(field_set_allocated:im.CMPHPLoginNotify.extend)
}

// -------------------------------------------------------------------

// CMPHPLoginNotifyACK

// string sUserId = 1;
inline void CMPHPLoginNotifyACK::clear_suserid() {
  suserid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CMPHPLoginNotifyACK::suserid() const {
  // @@protoc_insertion_point(field_get:im.CMPHPLoginNotifyACK.sUserId)
  return suserid_.GetNoArena();
}
inline void CMPHPLoginNotifyACK::set_suserid(const ::std::string& value) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.CMPHPLoginNotifyACK.sUserId)
}
#if LANG_CXX11
inline void CMPHPLoginNotifyACK::set_suserid(::std::string&& value) {
  
  suserid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.CMPHPLoginNotifyACK.sUserId)
}
#endif
inline void CMPHPLoginNotifyACK::set_suserid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.CMPHPLoginNotifyACK.sUserId)
}
inline void CMPHPLoginNotifyACK::set_suserid(const char* value, size_t size) {
  
  suserid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.CMPHPLoginNotifyACK.sUserId)
}
inline ::std::string* CMPHPLoginNotifyACK::mutable_suserid() {
  
  // @@protoc_insertion_point(field_mutable:im.CMPHPLoginNotifyACK.sUserId)
  return suserid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMPHPLoginNotifyACK::release_suserid() {
  // @@protoc_insertion_point(field_release:im.CMPHPLoginNotifyACK.sUserId)
  
  return suserid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMPHPLoginNotifyACK::set_allocated_suserid(::std::string* suserid) {
  if (suserid != NULL) {
    
  } else {
    
  }
  suserid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), suserid);
  // @@protoc_insertion_point(field_set_allocated:im.CMPHPLoginNotifyACK.sUserId)
}

// uint64 msgTime = 2;
inline void CMPHPLoginNotifyACK::clear_msgtime() {
  msgtime_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 CMPHPLoginNotifyACK::msgtime() const {
  // @@protoc_insertion_point(field_get:im.CMPHPLoginNotifyACK.msgTime)
  return msgtime_;
}
inline void CMPHPLoginNotifyACK::set_msgtime(::google::protobuf::uint64 value) {
  
  msgtime_ = value;
  // @@protoc_insertion_point(field_set:im.CMPHPLoginNotifyACK.msgTime)
}

// .im.ErrCode nErr = 3;
inline void CMPHPLoginNotifyACK::clear_nerr() {
  nerr_ = 0;
}
inline ::im::ErrCode CMPHPLoginNotifyACK::nerr() const {
  // @@protoc_insertion_point(field_get:im.CMPHPLoginNotifyACK.nErr)
  return static_cast< ::im::ErrCode >(nerr_);
}
inline void CMPHPLoginNotifyACK::set_nerr(::im::ErrCode value) {
  
  nerr_ = value;
  // @@protoc_insertion_point(field_set:im.CMPHPLoginNotifyACK.nErr)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace im

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_im_2ecm_2eproto
