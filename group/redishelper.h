/*****************************************************************************************
Filename: cache.h
Author: jack			Version: im-1.0 		Date:2017/06/14
Description: 	用户登录信息缓存、更新、缓存记录失效管理类定义
*****************************************************************************************/
#ifndef __REDISHELPER_H__
#define __REDISHELPER_H__
#include <string.h>
#include <stdlib.h>
#include "acl_cpp/lib_acl.hpp"
#include "acl_cpp/redis/redis_hash.hpp"
#include "acl_cpp/redis/redis_key.hpp"
#include "configfilereader.h"
#include "singleton.h"
#include "util.h"




#define LOGIN_FIELDS_COUNT 14
#define GROUP_FIELDS_COUNT 5
#define GROUPMEMBER_FIELDS_COUNT 1


using namespace std;


typedef enum _user_state
{
	USER_OFFLINE = 0,
	USER_ONLINE
} user_state;
//User login cache info, key:CM_XXX
typedef enum _user_cache_fields
{
	ROLE_FIELD = 0,			// user role, means to specify 		
	APPID_FIELD,			// app identification
	GROUPLIMIT_FIELD,		// total group limitation. 
	GROUPNUMBER_FIELD,		// Actual group number that has been created . 
	STATUS_FIELD,			// 0： offline ; 1: online	
	DEVICETYPE_FIELD,		// device type used to destinguish all kinds of mobile. 
	RELOGIN_FIELD,
	LOGINTOKEN_FIELD,
	DEVICETOKEN_FIELD,
	DEVICEVERSION_FIELD,
	IP_FIELD,
	PORT_FIELD,
	RELOGINTIME_FIELD,
	LOGINTIME_FIELD
} user_cache_fields;
	
//group cache info, key:GRP_XXX
typedef enum _group_cache_fields
{
	GROUPMASTER_FIELD,
	GROUPCOUNT_FIELD,
	GROUPSTATUS_FIELD,
	GROUPPERMIT_FIELD,
	GROUPCREATETIME_FIELD
} group_cache_fields;
//group member cache info, key:GRP_XXX_XXX
typedef enum _groupmember_cache_fields
{	
	MEMBERSTATUS_FIELD			//0: common member; 1: master member; 2: quit group; 3: kickout member
} groupmember_cache_fields;	


typedef struct _RedisPara
{
	int32_t nConnTimeout;
	int32_t nRwTimeout;
	int32_t nRetryInterval;
	int32_t nRetrySleep;
	int32_t nRetryLimit;
	int32_t nPoolSize;
	int32_t nKeyExpireTime;
	acl::string sRedisAddrs;
	acl::string sPassword;
} RedisPara_t;


typedef struct _UserCache
{
	acl::string sUserId; 		// redis cache key. (cm)_userId
	uint8_t bRole;				// User role , define by user center .  
	uint8_t bStatus;			// user on/off line status, 0: offline; 1: online; 
	uint8_t bDeviceType;		// 0x10: huawei phone; 0x11: xiaomi phone; -- ; 0xff: iphone
	uint8_t bRelogin;			// 0: new login ; 1: relogin;
	uint16_t nGroupLimit;		// total of group limitation
	uint16_t nGroupNumber;		// actual group number
	uint16_t nIPPort;			// current CM server Port 
	acl::string sIPAddr;		// current CM server IP address
	acl::string sLoginToken;    // generated by user center to validate user . 
	acl::string sDeviceToken;	// device token string.
	acl::string sDeviceVersion; // device version
	acl::string sAppId;			// 3rd-party application id
	acl::string sReloginTime;	// Refresh relogin timestamp .
	acl::string sLoginTime;		// The firt timestamp that user login . 

} UserCache_t;

typedef struct _GroupInfo
{
	acl::string sGroupId;
	acl::string sMasterId;
	uint16_t nGroupNumber;
	uint8_t bStatus;			// 0: normal； 1：dissolve
	uint8_t bPermit;			// 0: no necessary permission; 1: necessary permission; 2: forbidden;
	uint64_t createTime;
} GroupInfo_t;

typedef std::map<acl::string, acl::string> RedisMemberMap_t;

class CRedisHelper : public Singleton<CRedisHelper>
{
public:
	CRedisHelper();
	~CRedisHelper();
	
	bool Initialize(CConfigFileReader* pConfigReader);
	bool GetUserStatus(acl::redis_hash&      hashRedis,acl::string sUserId,uint8_t &bStatus);
	acl::redis_client_cluster* GetCluster(void) {return (acl::redis_client_cluster*)&m_cluster;}
	bool GetMemberStatus(acl::redis_hash&     hashRedis,acl::string sGroupKey,
							string sMemberId,uint8_t &bStatus);
	//bool GetGroupMaster(acl::redis_hash&     hashRedis,acl::string sGroupKey,string &sMasterId,uint8_t &bPermit);
	bool GetUserInfo(acl::redis_hash&     hashRedis,acl::string sUserId,UserCache_t &info);
	bool GetGroupInfo(acl::redis_hash&     hashRedis,acl::string sGroupKey,GroupInfo_t &info);
	bool InsertGroup(acl::redis_hash&     hashRedis,GroupInfo_t &info);
	bool InsertGroupMember(acl::redis_hash&      hashRedis,acl::string sGroupKey,string sMemberId, uint8_t bStatus);
	bool InsertGroupMember(acl::redis_hash&      hashRedis,acl::string sGroupKey,RedisMemberMap_t& memberMap);
	bool RemoveGroupMember(acl::redis_hash&      hashRedis,acl::redis& redis,acl::string sGroupKey,acl::string sMemberId);
	bool UpdateGroupCount(acl::redis_hash&      hashRedis,acl::redis& redis,acl::string sGroupKey,uint16_t nCount,uint8_t bMethod=0);
	bool UpdateGroupMaster(acl::redis_hash&      hashRedis,acl::string sGroupKey,acl::string sMasterId);
	bool UpdateGroupStatus(acl::redis_hash&      hashRedis, acl::redis& redis, acl::string sGroupKey,uint16_t status);
	bool SetUserStatus(acl::redis_hash&     hashRedis,acl::string sUserId,int8_t bStatus);
	bool UpdateUserRec(acl::redis_hash&     hashRedis,UserCache_t &rec,bool bAuthCheck);
	bool InsertUserRec(acl::redis_hash&     hashRedis,UserCache_t &rec);
	//bool DelUserRec(acl::redis&    redis,acl::string sUserId);
protected:
	bool SetRedisPara(void);	
private:
	CConfigFileReader* m_pConfigReader;
	acl::redis_client_cluster m_cluster;
	RedisPara_t m_redisPara;
	
};

#endif
