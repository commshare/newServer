// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: im.push.android.proto

#ifndef PROTOBUF_INCLUDED_im_2epush_2eandroid_2eproto
#define PROTOBUF_INCLUDED_im_2epush_2eandroid_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "im.pub.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_im_2epush_2eandroid_2eproto 

namespace protobuf_im_2epush_2eandroid_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
}  // namespace protobuf_im_2epush_2eandroid_2eproto
namespace im {
class ANDNotify;
class ANDNotifyDefaultTypeInternal;
extern ANDNotifyDefaultTypeInternal _ANDNotify_default_instance_;
class ANDNotifyAck;
class ANDNotifyAckDefaultTypeInternal;
extern ANDNotifyAckDefaultTypeInternal _ANDNotifyAck_default_instance_;
class ANDPushMsg;
class ANDPushMsgDefaultTypeInternal;
extern ANDPushMsgDefaultTypeInternal _ANDPushMsg_default_instance_;
class ANDPushMsgAck;
class ANDPushMsgAckDefaultTypeInternal;
extern ANDPushMsgAckDefaultTypeInternal _ANDPushMsgAck_default_instance_;
}  // namespace im
namespace google {
namespace protobuf {
template<> ::im::ANDNotify* Arena::CreateMaybeMessage<::im::ANDNotify>(Arena*);
template<> ::im::ANDNotifyAck* Arena::CreateMaybeMessage<::im::ANDNotifyAck>(Arena*);
template<> ::im::ANDPushMsg* Arena::CreateMaybeMessage<::im::ANDPushMsg>(Arena*);
template<> ::im::ANDPushMsgAck* Arena::CreateMaybeMessage<::im::ANDPushMsgAck>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace im {

// ===================================================================

class ANDPushMsg : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:im.ANDPushMsg) */ {
 public:
  ANDPushMsg();
  virtual ~ANDPushMsg();

  ANDPushMsg(const ANDPushMsg& from);

  inline ANDPushMsg& operator=(const ANDPushMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ANDPushMsg(ANDPushMsg&& from) noexcept
    : ANDPushMsg() {
    *this = ::std::move(from);
  }

  inline ANDPushMsg& operator=(ANDPushMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ANDPushMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ANDPushMsg* internal_default_instance() {
    return reinterpret_cast<const ANDPushMsg*>(
               &_ANDPushMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ANDPushMsg* other);
  friend void swap(ANDPushMsg& a, ANDPushMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ANDPushMsg* New() const final {
    return CreateMaybeMessage<ANDPushMsg>(NULL);
  }

  ANDPushMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ANDPushMsg>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ANDPushMsg& from);
  void MergeFrom(const ANDPushMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ANDPushMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sMsgId = 2;
  void clear_smsgid();
  static const int kSMsgIdFieldNumber = 2;
  const ::std::string& smsgid() const;
  void set_smsgid(const ::std::string& value);
  #if LANG_CXX11
  void set_smsgid(::std::string&& value);
  #endif
  void set_smsgid(const char* value);
  void set_smsgid(const char* value, size_t size);
  ::std::string* mutable_smsgid();
  ::std::string* release_smsgid();
  void set_allocated_smsgid(::std::string* smsgid);

  // string sTitle = 4;
  void clear_stitle();
  static const int kSTitleFieldNumber = 4;
  const ::std::string& stitle() const;
  void set_stitle(const ::std::string& value);
  #if LANG_CXX11
  void set_stitle(::std::string&& value);
  #endif
  void set_stitle(const char* value);
  void set_stitle(const char* value, size_t size);
  ::std::string* mutable_stitle();
  ::std::string* release_stitle();
  void set_allocated_stitle(::std::string* stitle);

  // string sBody = 5;
  void clear_sbody();
  static const int kSBodyFieldNumber = 5;
  const ::std::string& sbody() const;
  void set_sbody(const ::std::string& value);
  #if LANG_CXX11
  void set_sbody(::std::string&& value);
  #endif
  void set_sbody(const char* value);
  void set_sbody(const char* value, size_t size);
  ::std::string* mutable_sbody();
  ::std::string* release_sbody();
  void set_allocated_sbody(::std::string* sbody);

  // string sToId = 6;
  void clear_stoid();
  static const int kSToIdFieldNumber = 6;
  const ::std::string& stoid() const;
  void set_stoid(const ::std::string& value);
  #if LANG_CXX11
  void set_stoid(::std::string&& value);
  #endif
  void set_stoid(const char* value);
  void set_stoid(const char* value, size_t size);
  ::std::string* mutable_stoid();
  ::std::string* release_stoid();
  void set_allocated_stoid(::std::string* stoid);

  // string sDivece_Token = 7;
  void clear_sdivece_token();
  static const int kSDiveceTokenFieldNumber = 7;
  const ::std::string& sdivece_token() const;
  void set_sdivece_token(const ::std::string& value);
  #if LANG_CXX11
  void set_sdivece_token(::std::string&& value);
  #endif
  void set_sdivece_token(const char* value);
  void set_sdivece_token(const char* value, size_t size);
  ::std::string* mutable_sdivece_token();
  ::std::string* release_sdivece_token();
  void set_allocated_sdivece_token(::std::string* sdivece_token);

  // .im.MsgType eMsgType = 1;
  void clear_emsgtype();
  static const int kEMsgTypeFieldNumber = 1;
  ::im::MsgType emsgtype() const;
  void set_emsgtype(::im::MsgType value);

  // uint32 nGroupId = 3;
  void clear_ngroupid();
  static const int kNGroupIdFieldNumber = 3;
  ::google::protobuf::uint32 ngroupid() const;
  void set_ngroupid(::google::protobuf::uint32 value);

  // .im.DiveceType eDivece_type = 8;
  void clear_edivece_type();
  static const int kEDiveceTypeFieldNumber = 8;
  ::im::DiveceType edivece_type() const;
  void set_edivece_type(::im::DiveceType value);

  // @@protoc_insertion_point(class_scope:im.ANDPushMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr smsgid_;
  ::google::protobuf::internal::ArenaStringPtr stitle_;
  ::google::protobuf::internal::ArenaStringPtr sbody_;
  ::google::protobuf::internal::ArenaStringPtr stoid_;
  ::google::protobuf::internal::ArenaStringPtr sdivece_token_;
  int emsgtype_;
  ::google::protobuf::uint32 ngroupid_;
  int edivece_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_im_2epush_2eandroid_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ANDPushMsgAck : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:im.ANDPushMsgAck) */ {
 public:
  ANDPushMsgAck();
  virtual ~ANDPushMsgAck();

  ANDPushMsgAck(const ANDPushMsgAck& from);

  inline ANDPushMsgAck& operator=(const ANDPushMsgAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ANDPushMsgAck(ANDPushMsgAck&& from) noexcept
    : ANDPushMsgAck() {
    *this = ::std::move(from);
  }

  inline ANDPushMsgAck& operator=(ANDPushMsgAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ANDPushMsgAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ANDPushMsgAck* internal_default_instance() {
    return reinterpret_cast<const ANDPushMsgAck*>(
               &_ANDPushMsgAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ANDPushMsgAck* other);
  friend void swap(ANDPushMsgAck& a, ANDPushMsgAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ANDPushMsgAck* New() const final {
    return CreateMaybeMessage<ANDPushMsgAck>(NULL);
  }

  ANDPushMsgAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ANDPushMsgAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ANDPushMsgAck& from);
  void MergeFrom(const ANDPushMsgAck& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ANDPushMsgAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sMsgId = 1;
  void clear_smsgid();
  static const int kSMsgIdFieldNumber = 1;
  const ::std::string& smsgid() const;
  void set_smsgid(const ::std::string& value);
  #if LANG_CXX11
  void set_smsgid(::std::string&& value);
  #endif
  void set_smsgid(const char* value);
  void set_smsgid(const char* value, size_t size);
  ::std::string* mutable_smsgid();
  ::std::string* release_smsgid();
  void set_allocated_smsgid(::std::string* smsgid);

  // .im.ErrCode nErr = 2;
  void clear_nerr();
  static const int kNErrFieldNumber = 2;
  ::im::ErrCode nerr() const;
  void set_nerr(::im::ErrCode value);

  // @@protoc_insertion_point(class_scope:im.ANDPushMsgAck)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr smsgid_;
  int nerr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_im_2epush_2eandroid_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ANDNotify : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:im.ANDNotify) */ {
 public:
  ANDNotify();
  virtual ~ANDNotify();

  ANDNotify(const ANDNotify& from);

  inline ANDNotify& operator=(const ANDNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ANDNotify(ANDNotify&& from) noexcept
    : ANDNotify() {
    *this = ::std::move(from);
  }

  inline ANDNotify& operator=(ANDNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ANDNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ANDNotify* internal_default_instance() {
    return reinterpret_cast<const ANDNotify*>(
               &_ANDNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ANDNotify* other);
  friend void swap(ANDNotify& a, ANDNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ANDNotify* New() const final {
    return CreateMaybeMessage<ANDNotify>(NULL);
  }

  ANDNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ANDNotify>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ANDNotify& from);
  void MergeFrom(const ANDNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ANDNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sMsgId = 1;
  void clear_smsgid();
  static const int kSMsgIdFieldNumber = 1;
  const ::std::string& smsgid() const;
  void set_smsgid(const ::std::string& value);
  #if LANG_CXX11
  void set_smsgid(::std::string&& value);
  #endif
  void set_smsgid(const char* value);
  void set_smsgid(const char* value, size_t size);
  ::std::string* mutable_smsgid();
  ::std::string* release_smsgid();
  void set_allocated_smsgid(::std::string* smsgid);

  // string sToId = 2;
  void clear_stoid();
  static const int kSToIdFieldNumber = 2;
  const ::std::string& stoid() const;
  void set_stoid(const ::std::string& value);
  #if LANG_CXX11
  void set_stoid(::std::string&& value);
  #endif
  void set_stoid(const char* value);
  void set_stoid(const char* value, size_t size);
  ::std::string* mutable_stoid();
  ::std::string* release_stoid();
  void set_allocated_stoid(::std::string* stoid);

  // .im.ErrCode nErr = 3;
  void clear_nerr();
  static const int kNErrFieldNumber = 3;
  ::im::ErrCode nerr() const;
  void set_nerr(::im::ErrCode value);

  // @@protoc_insertion_point(class_scope:im.ANDNotify)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr smsgid_;
  ::google::protobuf::internal::ArenaStringPtr stoid_;
  int nerr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_im_2epush_2eandroid_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ANDNotifyAck : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:im.ANDNotifyAck) */ {
 public:
  ANDNotifyAck();
  virtual ~ANDNotifyAck();

  ANDNotifyAck(const ANDNotifyAck& from);

  inline ANDNotifyAck& operator=(const ANDNotifyAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ANDNotifyAck(ANDNotifyAck&& from) noexcept
    : ANDNotifyAck() {
    *this = ::std::move(from);
  }

  inline ANDNotifyAck& operator=(ANDNotifyAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ANDNotifyAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ANDNotifyAck* internal_default_instance() {
    return reinterpret_cast<const ANDNotifyAck*>(
               &_ANDNotifyAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ANDNotifyAck* other);
  friend void swap(ANDNotifyAck& a, ANDNotifyAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ANDNotifyAck* New() const final {
    return CreateMaybeMessage<ANDNotifyAck>(NULL);
  }

  ANDNotifyAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ANDNotifyAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ANDNotifyAck& from);
  void MergeFrom(const ANDNotifyAck& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ANDNotifyAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sMsgId = 1;
  void clear_smsgid();
  static const int kSMsgIdFieldNumber = 1;
  const ::std::string& smsgid() const;
  void set_smsgid(const ::std::string& value);
  #if LANG_CXX11
  void set_smsgid(::std::string&& value);
  #endif
  void set_smsgid(const char* value);
  void set_smsgid(const char* value, size_t size);
  ::std::string* mutable_smsgid();
  ::std::string* release_smsgid();
  void set_allocated_smsgid(::std::string* smsgid);

  // string sToId = 2;
  void clear_stoid();
  static const int kSToIdFieldNumber = 2;
  const ::std::string& stoid() const;
  void set_stoid(const ::std::string& value);
  #if LANG_CXX11
  void set_stoid(::std::string&& value);
  #endif
  void set_stoid(const char* value);
  void set_stoid(const char* value, size_t size);
  ::std::string* mutable_stoid();
  ::std::string* release_stoid();
  void set_allocated_stoid(::std::string* stoid);

  // .im.ErrCode nErr = 3;
  void clear_nerr();
  static const int kNErrFieldNumber = 3;
  ::im::ErrCode nerr() const;
  void set_nerr(::im::ErrCode value);

  // @@protoc_insertion_point(class_scope:im.ANDNotifyAck)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr smsgid_;
  ::google::protobuf::internal::ArenaStringPtr stoid_;
  int nerr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_im_2epush_2eandroid_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ANDPushMsg

// .im.MsgType eMsgType = 1;
inline void ANDPushMsg::clear_emsgtype() {
  emsgtype_ = 0;
}
inline ::im::MsgType ANDPushMsg::emsgtype() const {
  // @@protoc_insertion_point(field_get:im.ANDPushMsg.eMsgType)
  return static_cast< ::im::MsgType >(emsgtype_);
}
inline void ANDPushMsg::set_emsgtype(::im::MsgType value) {
  
  emsgtype_ = value;
  // @@protoc_insertion_point(field_set:im.ANDPushMsg.eMsgType)
}

// string sMsgId = 2;
inline void ANDPushMsg::clear_smsgid() {
  smsgid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ANDPushMsg::smsgid() const {
  // @@protoc_insertion_point(field_get:im.ANDPushMsg.sMsgId)
  return smsgid_.GetNoArena();
}
inline void ANDPushMsg::set_smsgid(const ::std::string& value) {
  
  smsgid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.ANDPushMsg.sMsgId)
}
#if LANG_CXX11
inline void ANDPushMsg::set_smsgid(::std::string&& value) {
  
  smsgid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.ANDPushMsg.sMsgId)
}
#endif
inline void ANDPushMsg::set_smsgid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  smsgid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.ANDPushMsg.sMsgId)
}
inline void ANDPushMsg::set_smsgid(const char* value, size_t size) {
  
  smsgid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.ANDPushMsg.sMsgId)
}
inline ::std::string* ANDPushMsg::mutable_smsgid() {
  
  // @@protoc_insertion_point(field_mutable:im.ANDPushMsg.sMsgId)
  return smsgid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ANDPushMsg::release_smsgid() {
  // @@protoc_insertion_point(field_release:im.ANDPushMsg.sMsgId)
  
  return smsgid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ANDPushMsg::set_allocated_smsgid(::std::string* smsgid) {
  if (smsgid != NULL) {
    
  } else {
    
  }
  smsgid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), smsgid);
  // @@protoc_insertion_point(field_set_allocated:im.ANDPushMsg.sMsgId)
}

// uint32 nGroupId = 3;
inline void ANDPushMsg::clear_ngroupid() {
  ngroupid_ = 0u;
}
inline ::google::protobuf::uint32 ANDPushMsg::ngroupid() const {
  // @@protoc_insertion_point(field_get:im.ANDPushMsg.nGroupId)
  return ngroupid_;
}
inline void ANDPushMsg::set_ngroupid(::google::protobuf::uint32 value) {
  
  ngroupid_ = value;
  // @@protoc_insertion_point(field_set:im.ANDPushMsg.nGroupId)
}

// string sTitle = 4;
inline void ANDPushMsg::clear_stitle() {
  stitle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ANDPushMsg::stitle() const {
  // @@protoc_insertion_point(field_get:im.ANDPushMsg.sTitle)
  return stitle_.GetNoArena();
}
inline void ANDPushMsg::set_stitle(const ::std::string& value) {
  
  stitle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.ANDPushMsg.sTitle)
}
#if LANG_CXX11
inline void ANDPushMsg::set_stitle(::std::string&& value) {
  
  stitle_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.ANDPushMsg.sTitle)
}
#endif
inline void ANDPushMsg::set_stitle(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  stitle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.ANDPushMsg.sTitle)
}
inline void ANDPushMsg::set_stitle(const char* value, size_t size) {
  
  stitle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.ANDPushMsg.sTitle)
}
inline ::std::string* ANDPushMsg::mutable_stitle() {
  
  // @@protoc_insertion_point(field_mutable:im.ANDPushMsg.sTitle)
  return stitle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ANDPushMsg::release_stitle() {
  // @@protoc_insertion_point(field_release:im.ANDPushMsg.sTitle)
  
  return stitle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ANDPushMsg::set_allocated_stitle(::std::string* stitle) {
  if (stitle != NULL) {
    
  } else {
    
  }
  stitle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stitle);
  // @@protoc_insertion_point(field_set_allocated:im.ANDPushMsg.sTitle)
}

// string sBody = 5;
inline void ANDPushMsg::clear_sbody() {
  sbody_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ANDPushMsg::sbody() const {
  // @@protoc_insertion_point(field_get:im.ANDPushMsg.sBody)
  return sbody_.GetNoArena();
}
inline void ANDPushMsg::set_sbody(const ::std::string& value) {
  
  sbody_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.ANDPushMsg.sBody)
}
#if LANG_CXX11
inline void ANDPushMsg::set_sbody(::std::string&& value) {
  
  sbody_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.ANDPushMsg.sBody)
}
#endif
inline void ANDPushMsg::set_sbody(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sbody_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.ANDPushMsg.sBody)
}
inline void ANDPushMsg::set_sbody(const char* value, size_t size) {
  
  sbody_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.ANDPushMsg.sBody)
}
inline ::std::string* ANDPushMsg::mutable_sbody() {
  
  // @@protoc_insertion_point(field_mutable:im.ANDPushMsg.sBody)
  return sbody_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ANDPushMsg::release_sbody() {
  // @@protoc_insertion_point(field_release:im.ANDPushMsg.sBody)
  
  return sbody_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ANDPushMsg::set_allocated_sbody(::std::string* sbody) {
  if (sbody != NULL) {
    
  } else {
    
  }
  sbody_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sbody);
  // @@protoc_insertion_point(field_set_allocated:im.ANDPushMsg.sBody)
}

// string sToId = 6;
inline void ANDPushMsg::clear_stoid() {
  stoid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ANDPushMsg::stoid() const {
  // @@protoc_insertion_point(field_get:im.ANDPushMsg.sToId)
  return stoid_.GetNoArena();
}
inline void ANDPushMsg::set_stoid(const ::std::string& value) {
  
  stoid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.ANDPushMsg.sToId)
}
#if LANG_CXX11
inline void ANDPushMsg::set_stoid(::std::string&& value) {
  
  stoid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.ANDPushMsg.sToId)
}
#endif
inline void ANDPushMsg::set_stoid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  stoid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.ANDPushMsg.sToId)
}
inline void ANDPushMsg::set_stoid(const char* value, size_t size) {
  
  stoid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.ANDPushMsg.sToId)
}
inline ::std::string* ANDPushMsg::mutable_stoid() {
  
  // @@protoc_insertion_point(field_mutable:im.ANDPushMsg.sToId)
  return stoid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ANDPushMsg::release_stoid() {
  // @@protoc_insertion_point(field_release:im.ANDPushMsg.sToId)
  
  return stoid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ANDPushMsg::set_allocated_stoid(::std::string* stoid) {
  if (stoid != NULL) {
    
  } else {
    
  }
  stoid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stoid);
  // @@protoc_insertion_point(field_set_allocated:im.ANDPushMsg.sToId)
}

// string sDivece_Token = 7;
inline void ANDPushMsg::clear_sdivece_token() {
  sdivece_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ANDPushMsg::sdivece_token() const {
  // @@protoc_insertion_point(field_get:im.ANDPushMsg.sDivece_Token)
  return sdivece_token_.GetNoArena();
}
inline void ANDPushMsg::set_sdivece_token(const ::std::string& value) {
  
  sdivece_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.ANDPushMsg.sDivece_Token)
}
#if LANG_CXX11
inline void ANDPushMsg::set_sdivece_token(::std::string&& value) {
  
  sdivece_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.ANDPushMsg.sDivece_Token)
}
#endif
inline void ANDPushMsg::set_sdivece_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sdivece_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.ANDPushMsg.sDivece_Token)
}
inline void ANDPushMsg::set_sdivece_token(const char* value, size_t size) {
  
  sdivece_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.ANDPushMsg.sDivece_Token)
}
inline ::std::string* ANDPushMsg::mutable_sdivece_token() {
  
  // @@protoc_insertion_point(field_mutable:im.ANDPushMsg.sDivece_Token)
  return sdivece_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ANDPushMsg::release_sdivece_token() {
  // @@protoc_insertion_point(field_release:im.ANDPushMsg.sDivece_Token)
  
  return sdivece_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ANDPushMsg::set_allocated_sdivece_token(::std::string* sdivece_token) {
  if (sdivece_token != NULL) {
    
  } else {
    
  }
  sdivece_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sdivece_token);
  // @@protoc_insertion_point(field_set_allocated:im.ANDPushMsg.sDivece_Token)
}

// .im.DiveceType eDivece_type = 8;
inline void ANDPushMsg::clear_edivece_type() {
  edivece_type_ = 0;
}
inline ::im::DiveceType ANDPushMsg::edivece_type() const {
  // @@protoc_insertion_point(field_get:im.ANDPushMsg.eDivece_type)
  return static_cast< ::im::DiveceType >(edivece_type_);
}
inline void ANDPushMsg::set_edivece_type(::im::DiveceType value) {
  
  edivece_type_ = value;
  // @@protoc_insertion_point(field_set:im.ANDPushMsg.eDivece_type)
}

// -------------------------------------------------------------------

// ANDPushMsgAck

// string sMsgId = 1;
inline void ANDPushMsgAck::clear_smsgid() {
  smsgid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ANDPushMsgAck::smsgid() const {
  // @@protoc_insertion_point(field_get:im.ANDPushMsgAck.sMsgId)
  return smsgid_.GetNoArena();
}
inline void ANDPushMsgAck::set_smsgid(const ::std::string& value) {
  
  smsgid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.ANDPushMsgAck.sMsgId)
}
#if LANG_CXX11
inline void ANDPushMsgAck::set_smsgid(::std::string&& value) {
  
  smsgid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.ANDPushMsgAck.sMsgId)
}
#endif
inline void ANDPushMsgAck::set_smsgid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  smsgid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.ANDPushMsgAck.sMsgId)
}
inline void ANDPushMsgAck::set_smsgid(const char* value, size_t size) {
  
  smsgid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.ANDPushMsgAck.sMsgId)
}
inline ::std::string* ANDPushMsgAck::mutable_smsgid() {
  
  // @@protoc_insertion_point(field_mutable:im.ANDPushMsgAck.sMsgId)
  return smsgid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ANDPushMsgAck::release_smsgid() {
  // @@protoc_insertion_point(field_release:im.ANDPushMsgAck.sMsgId)
  
  return smsgid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ANDPushMsgAck::set_allocated_smsgid(::std::string* smsgid) {
  if (smsgid != NULL) {
    
  } else {
    
  }
  smsgid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), smsgid);
  // @@protoc_insertion_point(field_set_allocated:im.ANDPushMsgAck.sMsgId)
}

// .im.ErrCode nErr = 2;
inline void ANDPushMsgAck::clear_nerr() {
  nerr_ = 0;
}
inline ::im::ErrCode ANDPushMsgAck::nerr() const {
  // @@protoc_insertion_point(field_get:im.ANDPushMsgAck.nErr)
  return static_cast< ::im::ErrCode >(nerr_);
}
inline void ANDPushMsgAck::set_nerr(::im::ErrCode value) {
  
  nerr_ = value;
  // @@protoc_insertion_point(field_set:im.ANDPushMsgAck.nErr)
}

// -------------------------------------------------------------------

// ANDNotify

// string sMsgId = 1;
inline void ANDNotify::clear_smsgid() {
  smsgid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ANDNotify::smsgid() const {
  // @@protoc_insertion_point(field_get:im.ANDNotify.sMsgId)
  return smsgid_.GetNoArena();
}
inline void ANDNotify::set_smsgid(const ::std::string& value) {
  
  smsgid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.ANDNotify.sMsgId)
}
#if LANG_CXX11
inline void ANDNotify::set_smsgid(::std::string&& value) {
  
  smsgid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.ANDNotify.sMsgId)
}
#endif
inline void ANDNotify::set_smsgid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  smsgid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.ANDNotify.sMsgId)
}
inline void ANDNotify::set_smsgid(const char* value, size_t size) {
  
  smsgid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.ANDNotify.sMsgId)
}
inline ::std::string* ANDNotify::mutable_smsgid() {
  
  // @@protoc_insertion_point(field_mutable:im.ANDNotify.sMsgId)
  return smsgid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ANDNotify::release_smsgid() {
  // @@protoc_insertion_point(field_release:im.ANDNotify.sMsgId)
  
  return smsgid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ANDNotify::set_allocated_smsgid(::std::string* smsgid) {
  if (smsgid != NULL) {
    
  } else {
    
  }
  smsgid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), smsgid);
  // @@protoc_insertion_point(field_set_allocated:im.ANDNotify.sMsgId)
}

// string sToId = 2;
inline void ANDNotify::clear_stoid() {
  stoid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ANDNotify::stoid() const {
  // @@protoc_insertion_point(field_get:im.ANDNotify.sToId)
  return stoid_.GetNoArena();
}
inline void ANDNotify::set_stoid(const ::std::string& value) {
  
  stoid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.ANDNotify.sToId)
}
#if LANG_CXX11
inline void ANDNotify::set_stoid(::std::string&& value) {
  
  stoid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.ANDNotify.sToId)
}
#endif
inline void ANDNotify::set_stoid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  stoid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.ANDNotify.sToId)
}
inline void ANDNotify::set_stoid(const char* value, size_t size) {
  
  stoid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.ANDNotify.sToId)
}
inline ::std::string* ANDNotify::mutable_stoid() {
  
  // @@protoc_insertion_point(field_mutable:im.ANDNotify.sToId)
  return stoid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ANDNotify::release_stoid() {
  // @@protoc_insertion_point(field_release:im.ANDNotify.sToId)
  
  return stoid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ANDNotify::set_allocated_stoid(::std::string* stoid) {
  if (stoid != NULL) {
    
  } else {
    
  }
  stoid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stoid);
  // @@protoc_insertion_point(field_set_allocated:im.ANDNotify.sToId)
}

// .im.ErrCode nErr = 3;
inline void ANDNotify::clear_nerr() {
  nerr_ = 0;
}
inline ::im::ErrCode ANDNotify::nerr() const {
  // @@protoc_insertion_point(field_get:im.ANDNotify.nErr)
  return static_cast< ::im::ErrCode >(nerr_);
}
inline void ANDNotify::set_nerr(::im::ErrCode value) {
  
  nerr_ = value;
  // @@protoc_insertion_point(field_set:im.ANDNotify.nErr)
}

// -------------------------------------------------------------------

// ANDNotifyAck

// string sMsgId = 1;
inline void ANDNotifyAck::clear_smsgid() {
  smsgid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ANDNotifyAck::smsgid() const {
  // @@protoc_insertion_point(field_get:im.ANDNotifyAck.sMsgId)
  return smsgid_.GetNoArena();
}
inline void ANDNotifyAck::set_smsgid(const ::std::string& value) {
  
  smsgid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.ANDNotifyAck.sMsgId)
}
#if LANG_CXX11
inline void ANDNotifyAck::set_smsgid(::std::string&& value) {
  
  smsgid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.ANDNotifyAck.sMsgId)
}
#endif
inline void ANDNotifyAck::set_smsgid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  smsgid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.ANDNotifyAck.sMsgId)
}
inline void ANDNotifyAck::set_smsgid(const char* value, size_t size) {
  
  smsgid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.ANDNotifyAck.sMsgId)
}
inline ::std::string* ANDNotifyAck::mutable_smsgid() {
  
  // @@protoc_insertion_point(field_mutable:im.ANDNotifyAck.sMsgId)
  return smsgid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ANDNotifyAck::release_smsgid() {
  // @@protoc_insertion_point(field_release:im.ANDNotifyAck.sMsgId)
  
  return smsgid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ANDNotifyAck::set_allocated_smsgid(::std::string* smsgid) {
  if (smsgid != NULL) {
    
  } else {
    
  }
  smsgid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), smsgid);
  // @@protoc_insertion_point(field_set_allocated:im.ANDNotifyAck.sMsgId)
}

// string sToId = 2;
inline void ANDNotifyAck::clear_stoid() {
  stoid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ANDNotifyAck::stoid() const {
  // @@protoc_insertion_point(field_get:im.ANDNotifyAck.sToId)
  return stoid_.GetNoArena();
}
inline void ANDNotifyAck::set_stoid(const ::std::string& value) {
  
  stoid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.ANDNotifyAck.sToId)
}
#if LANG_CXX11
inline void ANDNotifyAck::set_stoid(::std::string&& value) {
  
  stoid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.ANDNotifyAck.sToId)
}
#endif
inline void ANDNotifyAck::set_stoid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  stoid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.ANDNotifyAck.sToId)
}
inline void ANDNotifyAck::set_stoid(const char* value, size_t size) {
  
  stoid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.ANDNotifyAck.sToId)
}
inline ::std::string* ANDNotifyAck::mutable_stoid() {
  
  // @@protoc_insertion_point(field_mutable:im.ANDNotifyAck.sToId)
  return stoid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ANDNotifyAck::release_stoid() {
  // @@protoc_insertion_point(field_release:im.ANDNotifyAck.sToId)
  
  return stoid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ANDNotifyAck::set_allocated_stoid(::std::string* stoid) {
  if (stoid != NULL) {
    
  } else {
    
  }
  stoid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stoid);
  // @@protoc_insertion_point(field_set_allocated:im.ANDNotifyAck.sToId)
}

// .im.ErrCode nErr = 3;
inline void ANDNotifyAck::clear_nerr() {
  nerr_ = 0;
}
inline ::im::ErrCode ANDNotifyAck::nerr() const {
  // @@protoc_insertion_point(field_get:im.ANDNotifyAck.nErr)
  return static_cast< ::im::ErrCode >(nerr_);
}
inline void ANDNotifyAck::set_nerr(::im::ErrCode value) {
  
  nerr_ = value;
  // @@protoc_insertion_point(field_set:im.ANDNotifyAck.nErr)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace im

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_im_2epush_2eandroid_2eproto
